[{"title":"到底什么是标准和怪异","date":"2017-08-07T02:27:53.000Z","path":"2017/08/07/017/","text":"在标准模式下，一个块的总宽度=width+margin(左右)+padding(左右)+border(左右)在怪异模式下，一个块的总宽度=width+margin（左右）（既width已经包含了padding和border值） .con_box&#123; box-sizing: content-box; width: 100px; height: 100px; padding: 10px; margin: 50px; border: 10px solid green; background: red;&#125; 在线演示截图：.ie_box&#123; box-sizing: border-box; width: 100px; height: 100px; border: 10px solid green; padding: 10px; margin: 50px; background: red;&#125; 在线演示截图：","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"DOM事件","date":"2017-08-07T01:47:53.000Z","path":"2017/08/07/016/","text":"JavaScript与HTML之间的交互式通过事件实现的。事件就是文档或者浏览器窗口中发生的一些特定的交互瞬间。 事件流即事件传播（event propagation），描述的是从页面接收事件的顺序。IE的是事件冒泡流，Netcape是事件捕获流。 1.事件冒泡IE的事件流叫做事件冒泡（event bubbing），即事件最开始由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播至较为不具体的那个节点（文档）。IE9等会一直冒泡到window对象。 2.事件捕获Netcape提出的另一种事件流叫做事件捕获（event capturing）。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。目前现代浏览器（IE9、chrome等）都支持这种这种事件流模型。但因为老版本不支持，很少使用。 DOM事件流“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。IE9等都会在捕获阶段触发事件对象上的事件。结果就是有两个机会在目标对象上面操作事件。IE8之下不支持DOM事件流。 事件处理程序事件处理程序（event handler）或事件监听程序（event listener）是处理或者响应事件的函数。处理事件程序的名字以”on”开头，比如click事件的事件处理程序就是onclick 1.HTML事件处理程序某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定。这个特性的值应该是能够执行的JavaScript代码。&lt;input type=\"button\" value=\"HTML事件处理程序\" id=\"btn1\" onclick=\"showMes()\"&gt; 缺点1.时差问题：使用try-catch块捕捉错误。onclick=”try { showMessage() ;} catch(ex) {}”2.程序的作用域链在不同浏览器中会导致不同结果3.HTML和JS代码耦合紧密 2.DOM0级事件处理程序通过JS指定时间处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。首先要取得一个要操作的对象的引用。每个元素（包括window和document）都有自己的事件处理程序属性，这些属性通常全部小写，例如onclick。将这种属性的值设置为一个函数就可以指定事件处理程序。var btn2 = document.getElementById(\"btn2\");btn2.onclick = function() &#123; alert(\"这是通过DOM0级添加的事件\");&#125;; 优点:比较简单，跨浏览器的优势事件处理程序在元素的作用域中运行，this指向当前元素。会在事件流的冒泡阶段被处理删除事件处理程序：btn.onclick = null; 3.DOM2级事件处理程序DOM2级事件定义了两个方法：用于处理指定和删除事件处理程序的操作addEventListener和removeEventListener。接收3个参数，要处理的事件名称（不包含on）、作为事件处理程序的函数和一个布尔值。如果为true，表示在捕获时执行事件处理函数；如果为false，表示在冒泡阶段调用事件处理程序。大多数情况下用false。 addEventListener()添加的只能用removeEventListener()删除，而且参数都要一致。好处：可以添加多个事件处理程序。先添加先执行。问题：匿名函数无法移除。 var handler = function()&#123; alert(this.id);&#125;;btn.addEventListener(\"click\", handler, false);btn.removeEventListener(\"click\", handler, false); 4.IE事件处理程序attachEvent()添加事件detachEvent()删除事件接收两个参数：事件处理程序的名称（有on）和事件处理程序的函数 没有第三个参数，是因为IE8及更早版本只支持事件冒泡，默认添加到冒泡阶段注意：使用DOM方法时，事件会在所属元素的作用域内运行；使用attachEvent()方法，事件处理程序会在全局作用域运行，this等于window。好处：可以添加多个事件处理程序。后添加先执行。问题：匿名函数无法移除。支持IE事件处理的有IE和Opera var handler = function()&#123; alert(this.id);&#125;;btn.attachEvent (“onclick”, handler);btn.detachEvent (“onclick”, handler); 5.跨浏览器的事件处理程序创建一个对象eventUtil，拥有两个方法。addHandler(要操作的元素，事件名称，事件处理函数)。removeHandler(要操作的元素，事件名称，事件处理函数)。 var eventUtil = &#123; //添加句柄 addHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = handler; &#125; &#125;, //删除句柄 removeHandler: function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.attachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = null; &#125; &#125;&#125; 事件对象事件对象（event object）：在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。1.DOM中的事件对象（1）type属性 被触发的事件的类型（2）target属性 事件的目标（3）stopPropagation()方法 取消事件的进一步捕获或冒泡（4）preventDefault()方法 取消事件的默认行为2.IE中的事件对象event对象作为window对象的一个属性存在。（1）type属性 被触发的事件的类型（2）srcElement属性 事件的目标（3）cancelBubble属性 默认为false，设置成true可阻止事件冒泡（4）returnValue属性 默认值为ture，设置成false可取消时间的默认行为 由于IE不支持事件捕获， 更多属性方法，可查看W3C的事件：W3C的DOM事件参考手册 3.跨浏览器的事件对象var eventUtil = &#123; addHandler: function(element, type, handler) &#123; //忽略 &#125;, removeHandler: function(element, type, handler) &#123; //忽略 &#125;， getEvent: function(event) &#123; return event ? event : window.event; &#125;, getType: function(event) &#123; return event.type; &#125;, getElement: function(event) &#123; return event.target || event.srcElement; &#125;, preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;&#125; 事件类型一. DOM3级事件规定以下类型：UI事件：当用户与页面上的元素交互时触发焦点事件：当元素获得或失去焦点时触发鼠标事件：当用户通过鼠标在页面上执行操作时触发滚轮事件：当使用鼠标滚轮时触发文本事件：当在文档中输入文本时触发键盘事件：在用户通过键盘在页面上执行操作时触发合成事件：当为输入法编辑器输入字符时触发变动事件：当底层DOM结构发生变化时触发 二. UI事件UI事件：当用户与页面上的元素交互时触发1.load事件当页面完全加载后（包括所有图形、JavaScript文件、CSS文件等外部），就会触发window上面的load事件。window.onload = function() &#123; alert(\"loaded!\");&#125; 图像上面也可以触发load事件。在创建新的img元素时，要在指定src属性之前先指定事件。&lt;!--img元素也可以指定load事件，当图像成功下载执行load事件--&gt; &lt;!--如果图像路径有误，或者其他原因导致没有下载完成，则不会执行load事件--&gt; &lt;img src=\"smile.gif\" onload=\"alert('Image loaded.')\" /&gt; 在IE9+的浏览器中，script标签也能触发load事件。 2.unload事件unload事件在文档被完全卸载后触发，只要用户从一个页面切换到另一个页面，就会发生unload事件。利用这个事件最多的情况是清除引用，以避免内存泄露。 3.resize事件当浏览器窗口被调整到一个新的高度或宽度时，就会触发resize事件，这个事件在window上面触发。resize事件有可能被频繁执行，因此不适合在这个事件的处理程序中加入大计算量的代码。 4.scroll事件scroll事件是在window对象上发生的，但它实际表示的是页面中相应元素的变化。与resize事件类似，scroll事件也会在文档被滚动期间重复被触发。 三. 焦点事件焦点元素会在页面元素获得或失去焦点时触发。利用这些事件并于document.hasFocus()方法及document.activeElement属性配合，可以知晓用户在页面上的行踪。 常用焦点事件： 名称 触发方式 是否冒泡 blur 元素失去焦点时触发 否 focus 元素获得焦点时触发 否 focusin 元素获得焦点时触发 是 focusout 元素失去焦点时触发 是 四. 鼠标事件鼠标事件是Web开发中最常用的一类事件。1.列表 名称 触发方式 是否冒泡 click 单击鼠标左键或按下回车键 是 dblclick 双击鼠标左键 是 mousedown 按下任意鼠标按钮 是 mouseup 释放任意鼠标按键 是 mouseenter 鼠标指针从元素外部首次移动到元素范围内 否 mouseleave 鼠标指针从元素范围内移出 否 mouseout 鼠标指针位于一个元素上方，然后移入另一个元素 是 mouseover 鼠标指针从元素外部首次移动到元素范围内 是 mousemove 鼠标指针在元素内部移动 是 2.关联只有在同一个元素上相继触发mousedown和mouseup事件，才会触发click事件。只有触发两次click事件，才会触发一次dblclick事件。IE6 - 8中，双击时会跳过第二次mousedown和click事件.3.坐标位置鼠标事件发生的坐标位置保存在事件对象中。myDIv.addEventListener(\"click\", function(e)&#123; alert(e.clientX + \",\" + e.clientY); //在窗口中的位置 alert(e.pageX + \",\" + e.pageY); //在页面中的位置 alert(e.screenX + \",\" + e.screenY); //在屏幕中的位置&#125;, false); 参考资料：JS高级程序设计W3school HTML DOM参考手册","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"是Ajax啊","date":"2017-08-01T07:24:53.000Z","path":"2017/08/01/013/","text":"Ajax = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。Ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。Ajax技术的核心是XMLHttpRequest对象（简称XHR），运用XMLHttpRequest对象使后台与服务器进行数据交换，在重新加载页面的情况下取得新数据，再通过DOM操作将新数据插入到页面中。 XMLHttpRequest对象IE7+、Firefox、Chrome、Safari以及Opera都支持原生的XMLHttpRequest对象。在这些浏览器中可以使用XMLHttpRequest构造函数。var xhr = new XMLHttpRequest();在老版本的 Internet Explorer（IE5 和 IE6）使用 ActiveX 对象：variable=new ActiveXObject(“Microsoft.XMLHTTP”); XMLHttpRequest的属性收到响应后，响应的数据会自动填充XHR对象的属性：1.responseText属性:获得字符串形式的响应数据。2.responseXML属性:获得XML形式的响应数据。3.status属性:响应的HTTP状态4.statusText属性:HTTP状态的说明 xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304 5.readyState属性：存有XMLHttpRequest的状态，表示请求/响应过程的当前活动阶段。从0到4发生变化。&emsp;0: 未初始化。尚未调用open()方法&emsp;1: 启动。已经调用open()方法，但尚未调用send()方法&emsp;2: 发送。已经调用send()方法，但尚未接收到响应&emsp;3: 接收。已经接收到部分响应数据&emsp;4: 完成。已经接收到全部响应数据，而且已经可以在客户端使用了 xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200 //响应已就绪 6.onreadystatechange事件readyState的值每变化一次就触发一次onreadystatechange事件，必须在调用open()之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性。 XMLHttpRequest的方法1.open(method,url,async) 规定请求的类型、URL 以及是否异步处理请求。&emsp;method：请求的类型：GET 或 POST&emsp;url：请求的地址，文件在服务器上的位置&emsp;async：true（异步）或 false（同步）默认true 2.send(string) 将请求发送到服务器。send()方法接收一个参数即要作为请求主体发送的数据，如果不需要通过请求主体发送数据（比如GET请求)，则必须传入null（空的话有些浏览器不支持）。POST请求不给参数无意义，所以一般要接收一个string。 3.abort()方法 取消异步请求调用这个方法后，XHR对象会停止触发事件，而且也不再允许访问任何与响应有关的对象属性。将XMLHttpRequest 对象重置为 readyState 为 0 的状态。 4.setRequestHeader（）这个方法只有当 readyState 为 1 的时候才能调用，必须在调用open()方法之后且调用send()方法之前调用setRequestHeader()。然后在 send() 方法中规定您希望发送的数据。setRequestHeader(header,value) 向请求添加 HTTP 头。 5.getAllResponseHeaders()把 HTTP 响应头部作为未解析的字符串返回。如果 readyState 小于 3，这个方法返回 null。否则，它返回服务器发送的所有 HTTP 响应的头部。头部作为单个的字符串返回，一行一个头部。每行用换行符 “\\r\\n” 隔开。 6.getResponseHeader()返回指定的 HTTP 响应头部的值。其参数是要返回的 HTTP 响应头部的名称。可以使用任何大小写来制定这个头部名字，和响应头部的比较是不区分大小写的。该方法的返回值是指定的 HTTP 响应头部的值，如果没有接收到这个头部或者 readyState 小于 3 则为空字符串。如果接收到多个有指定名称的头部，这个头部的值被连接起来并返回，使用逗号和空格分隔开各个头部的值。 GET请求GET请求用于向服务器查询某些信息，可以将查询字符串参数追加到URL的末尾，以便将信息发送给服务器。查询字符串中每个参数的名称和值都必须使用encodeURIComponent()进行编码。 encodeURI() 函数可把字符串作为 URI 进行编码。返回URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换。该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&amp;=+$,#而如果 URI 组件中含有分隔符，比如 ? 和 #，则应当使用 encodeURIComponent() 方法分别对各组件进行编码。encodeURIComponent()：其他字符（;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的 POST请求POST请求的主体可以包含非常多的数据，而且格式不限。在open()方法的第一个参数的位置传入”POST”，就可以初始化一个POST请求。发送POST请求的第二部是向send()方法中传入某些数据。 我们可以将Content-Type头部信息设置为application/x-www-form-urlencoded模拟表单提交 跨源资源共享同源策略是对XHR的一个主要约束，它为通信设置了“相同的域，相同的端口，相同的协议”这一限制。默认情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。这种安全策略可以预防某些恶意行为，但是合理的跨域请求对开发某些浏览器应用程序至关重要。跨域资源共享Cross Origin Resource Sharing(CORS)定义了在必须访问跨域资源时，浏览器与服务器如何沟通。CORS的背后基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求响应是应该成功还是应该失败。 IE对CORS的实现：微软IE8引入了XDR(XDomainRequest)类型。这个对象与XHR类似，但能实现安全可靠的跨域通信。XDR对象的安全机制部分实现了W3C的CORS规范。XDR与XHR的不同之处：&emsp;cookie不会随请求发送也不会随响应返回。&emsp;只能设置请求头部信息中的Content-Type字段&emsp;不能访问响应头部信息&emsp;只支持GET和POST请求这些变化使CSRF(Cross-Site Request Forgery,跨站点请求伪造)和XSS(Cross-Site Scripting,跨站点脚本)的问题得到了缓解。 其他主流浏览器通过XMLHttpRequest对象实现了对CORS的原生支持。要请求位于另一个域中的资源，使用标准的XHR对象并在open()方法中传入绝对URL即可。跨域XHR对象可以访问status和statusText属性，而且支持同步请求。跨域XHR对象也有一些限制：&emsp;不能使用setRequestHeader()设置自定义头部&emsp;不能发送和接收cookie&emsp;调用getAllResponseHeaders()方法总会返回空字符串由于无论同源请求还是跨域请求都是用相同的接口，因此对于本地资源，最好使用相对URL，在访问远程资源时再使用绝对URL 其他跨域技术1.图像Ping图像Ping是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或者204响应。通过图像Ping浏览器得不到任何具体的数据，但通过侦听load和error事件，它能知道响应式什么时候接收到的。图像Ping最常用于跟踪用户点击页面或者动态官高曝光次数。图像Ping有两个主要的缺点，一时之能发送GET请求，二是无法访问服务器的响应文本。因此，它只能用于浏览器与服务器间的单向通信。 2.JSONPJSON with Padding，这里的 Padding 指的就是包裹在 JSON 外层的回调函数AJAX 无法跨域是受到“同源政策”的限制，但是带有src属性的标签（例如script、img、iframe）是不受该政策限制的，因此我们可以通过向页面中动态添加script标签来完成对跨域资源的访问，这也是 JSONP 方案最核心的原理。与图像Ping相比，它的优点是在于能够直接访问响应文本，支持在浏览器与服务器之间双向通信。但它是从其他域中加载代码执行，不能保证安全可靠。其次，确定JSONP请求是否失败并不容易。 JSON一种表示结构化数据的格式。JSON数据的书写格式：名称/值对中间用冒号隔开JSON的值类型：&emsp;简单值：字符串（双引号）、数值、布尔值（true false）和null，但不支持undefined&emsp;对象：一组无序的键值对儿。用{}&emsp;数组：一组有序的值的列表，可以通过数值索引来访问其中的值。用[] 与JS对象不同在于：JSON对象没有声明对象，其次没有末尾的分号，而且对象的属性必须加双引号。数组也没有变量和分号 JSON解析eval()函数可以解析、解释并返回JavaScript对象和数组。但eval()存在风险，尽量不要使用。不能原生支持JSON解析的浏览器，使用shim是最佳选择。 JSON对象有两个方法：stringify() 用于把JavaScript对象序列化为JSON字符串。默认输出的JSON字符串不包含任何空格字符或缩进。可以接收另外两个参数，第一个参数是过滤器（replacer），可以是数组也可以是函数。第二个参数是一个选项，表示是否在JSON字符串中保留缩进，如果这个参数是一个数值，它代表的是每个级别缩进的空格数。还可以给原生的对象定义toJSON()方法，返回其自身的JSON数据格式。 parse() 把JSON字符串解析为原生的JavaScript值。可以接受另一个参数，该参数是一个函数(reviver)，将在每个键值对上调用。","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"凉夜对词","date":"2017-07-31T15:32:15.000Z","path":"2017/07/31/012/","text":"婕叹“时光容易把人抛，红了樱桃，绿了芭蕉”，机智的我赶紧怼她“是流光容易把人抛”，她不服，我搬出原文《一剪梅·舟过吴江》 一片春愁待酒浇。江上舟摇，楼上帘招。秋娘渡与泰娘桥，风又飘飘，雨又萧萧。何日归家洗客袍？银字笙调，心字香烧。流光容易把人抛，红了樱桃，绿了芭蕉。 感叹传世名句后继续说起蒋捷另一首闻名于世的《虞美人·听雨》 少年听雨歌楼上，红烛昏罗帐。壮年听雨客舟中，江阔云低，断雁叫西风。而今听雨僧庐下，鬓已星星也。悲欢离合总无情，一任阶前点滴到天明。 婕说她越来越能体会少年壮年的那种变化，我开始说我喜欢的几首词。周邦彦的《解连环》 怨怀无托，嗟情人断绝，信音辽邈。纵妙手、能解连环，似风散雨收，雾轻云薄。燕子楼空，暗尘锁、一床弦索。想移根换叶，尽是旧时，手种红药。汀洲渐生杜若。料舟移岸曲，人在天角。谩记得、当日音书，把闲语闲言，待总烧却。水驿春回，望寄我、江南梅萼。拼今生，对花对酒，为伊泪落。 贺铸的《青玉案》 凌波不过横塘路，但目送、芳尘去。锦瑟华年谁与度？月桥花院，琐窗朱户，只有春知处。飞云冉冉蘅皋暮，彩笔新题断肠句。试问闲情都几许？一川烟草，满城风絮，梅子黄时雨。 我说我就是喜欢这种无端端又没什么大追求的小忧伤……就连辛弃疾我都更爱他的《摸鱼儿》。 更能消，几番风雨？匆匆春又归去。惜春长怕花开早，何况落红无数。春且住，见说道，天涯芳草无归路。怨春不语，算只有殷勤，画檐蛛网，镇日惹飞絮。长门事，准拟佳期又误，蛾眉曾有人妒。千金纵买相如赋，脉脉此情谁诉？君莫舞，君不见，玉环飞燕皆尘土。闲愁最苦，休去倚危栏，斜阳正在，烟柳断肠处。 那些壮阔激昂的家国情怀在课本里、在试卷上“体会”了太多，于我而言只有标准答案却没有共情，反而诗词里的儿女情长、伤春悲秋、感时悲逝的情绪最触动我。 夏夜难得的凉爽，有穿堂风过。心情太好，似乎有些难眠。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://wongyirong.github.io/tags/随笔/"}]},{"title":"JavaScript 错误 - Throw、Try 和 Catch","date":"2017-07-31T12:56:03.000Z","path":"2017/07/31/011/","text":"当 JavaScript 引擎执行 JavaScript 代码时，会发生各种错误。可能是语法错误，通常是程序员造成的编码错误或错别字。可能是拼写错误或语言中缺少的功能（可能由于浏览器差异）。可能是由于来自服务器或用户的错误输出而导致的错误。当然，也可能是由于许多其他不可预知的因素。 JavaScript 测试和捕捉try 语句允许我们定义在执行时进行错误测试的代码块。catch 语句允许我们定义当 try 代码块发生错误时，所执行的代码块。JavaScript 语句 try 和 catch 是成对出现的。语法try&#123;//在这里运行代码&#125;catch(err)&#123;//在这里处理错误&#125; Throw 语句throw 语句允许我们创建自定义错误。正确的技术术语是：创建或抛出异常（exception）。如果把 throw 与 try 和 catch 一起使用，那么您能够控制程序流，并生成自定义的错误消息。语法throw exception 异常可以是 JavaScript 字符串、数字、逻辑值或对象。","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"一个问题引出的正则表达式总结","date":"2017-07-27T00:44:02.000Z","path":"2017/07/27/010/","text":"早上我同学给我发了张截图，让我给她解释一下这段正则的含义。/^(?:([A-Za-z]+):)?(\\/&#123;0,3&#125;)([0-9.\\-A-Aa-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/ 刚开始看觉得好乱，但仔细看一下里面的语法都是熟悉的，我耐下心来，在笔记本画了下草图就感觉比较清晰了，这是一段匹配URL的正则表达式文本。理清后觉得很有必要做一些整理归纳工作，加强对正则表达式的语法记忆，也为自己建立一个参考手册。 regexp对象JavaScript内置对象RegExp实例化有两种方式：1.字面量var reg1 = /\\bbaidu\\b/g;2.构造函数：var reg2 = new RegExp(“\\bbaidu\\b”, “g”); 修饰符g:global 全文搜索 不加g默认找到第一个匹配就停止i:ignore case 忽略大小写 默认是大小写敏感m:multiple lines 多行搜索 元字符元字符是在正则表达式中有特殊含义的非字母字符1.有特殊含义的标点符号* + ? $ ^ . | \\ ( ) &#123; &#125; [ ] 2.直接量字符 字符 含义 字母及数字 自身 \\t 水平制表符 \\v 垂直制表符 \\n 换行符 \\r 回车符 \\0 空字符 \\f 换页符 3.字符类(1)将直接量字符单独放进方括号内就组成了字符类。一个字符类可以匹配它所包含的任意字符。(2)可以通过“^”符号定义否定字符类，匹配所有不在方括号内的字符。(3)还可以用“-”来表示范围a-z，类内部是可以连写的a-zA-Z。 4.预定义类 匹配常见的字符类 字符 等价类 含义 . [^\\r\\n] 除了回车符和换行符之外的所有字符 \\d [0-9] 数字字符 \\D [^0-9] 非数字字符 \\s [\\t\\n\\x0B\\f\\r] 空白符 \\S [^\\t\\n\\x0B\\f\\r] 非空白符 \\w [a-zA-Z_0-9] 单词字符（字母、数字、下划线） \\W [^a-zA-Z_0-9] 非单词字符 5.常用的边界匹配字符（锚字符） 字符 含义 ^ 匹配字符串的开头 $ 匹配字符串的结尾 \\b 单词边界 \\B 非单词边界 \\b 单词边界 (\\b并不匹配单词分隔字符中的任何一个，它只匹配一个位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\\w单词字符)另外：多行匹配时，加上/m后“^”才可以匹配一行的开始，$也是。 量词（重复） 字符 含义 {n,m} 匹配前一项至少n次，但不超过m次 {n,} 匹配前一项n次到多次 {n} 匹配前一项n次 ? 匹配前一项0次或1次，等价于{0,1} + 匹配前一项1次或者多次，等价于{1,} * 匹配前一项0次或多次，等价于{0,} 贪婪模式：匹配重复字符是尽可能多地匹配。默认。而非贪婪模式，只需要在量词后加上一个问号。 分组使用()分组，使量词作用于分组默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。1.使用|可以达到或的效果2.后向引用后向引用用于重复搜索前面某个分组匹配的文本。例如，\\1代表分组1匹配的文本。3.忽略分组不希望捕获某些分组，只需要在分组内加上?:就可以 零宽先行断言1.(?=p)零宽正向先行断言要求接下来的字符都与p匹配，但不能包括匹配p的那些字符。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re studying.时，它会匹配sing和study。2.(?!p)零宽负向先行断言要求接下来的字符不与p匹配 RegExp对象1.五个RegExp对象属性：global、multiline、ignoreCase、lastIndex、source(1)lastIndex：当前表达式匹配内容的最后一个字符的下一个位置(2)source：只读，正则表达式的文本字符串2.两个RegExp对象方法：(1)RegExpObject.test(string)test()方法用于检测一个字符串是否匹配某个模式.如果字符串 string 中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false。(2)RegExpObject.exec(string)exec()方法用于检索字符串中的正则表达式的匹配。如果没有匹配返回null,否则返回一个结果数组。返回的数组具有两个属性：index和input。&emsp;1)数组第一个元素包含的是与正则表达式相匹配的字符串&emsp;2)余下的元素是与子表达式相匹配的字符串&emsp;3)index声明匹配文本的其实字符在字符串的位置&emsp;4)input声明对stringObject的引用 用于模式匹配的String方法1.stringObject.search(regexp)search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。返回第一个匹配结果的index，查找不到返回-1search()方法不支持全局检索，它将忽略修饰符g，并且总是从字符串的开始进行检索。 2.stringObject.match(regexp)match()方法将检索字符串以找到一个或多个正则表达式的匹配。返回一个由匹配结果组成的数组，该数组的内容依赖于 regexp 是否设置了修饰符g。&emsp;(1)没有设置g，非全局检索它只执行一次匹配，如果没有找到任何的匹配文本，返回null否则将返回一个数组，数组第一项存放的是完整的匹配，剩下的存放的是与子表达式相匹配的字符串。返回的数组具有两个属性：index和input（非全局检索与exec返回的一模一样）&emsp;(2)设置了g，全局检索没有找到返回null，找到返回一个数组包含字符串中所有匹配结果。没有index属性和input属性 3.stringObject.split(regexp)split() 方法用于把一个字符串分割成字符串数组。返回一个字符串数组。 4.stringObject.replace(regexp, replacement)replace()方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。返回一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。replacement 可以是字符串，也可以是函数。&emsp;(1)如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。它说明从模式匹配得到的字符串将用于替换。&emsp;(2)replacement是函数的情况，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是index，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。 最后让我们再回到最开始的问题，看着这张可视化工具生成的图，再次回忆一下语法。是不是很容易理解了。 参考资料：《JaveScript权威指南》《正则表达式30分钟入门教程》《微软的正则表达式教程》在线网站：正则表达式可视化工具正则表达式学习正则表达式练习 有没有发现我的MD语法进步了呢……","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"使用node.js和mongoDB建站","date":"2017-07-26T00:44:02.000Z","path":"2017/07/26/009/","text":"这两天跟着慕课网的一个视频学习node.js和MongoDB建站，第一次使用MongoDB，看着教程学习了一下基本使用。 git将本地项目上传到github(git status)，首先在github上创建一个Git仓库 git init git add . git commit -m &quot;first commit&quot; git remote add origin https://github.com/wongyirong/iMooc.git git push -u origin master 另外:由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库有了内容之后，下次使用git push origin master还有一个问题，当时我在github上创建仓库的时候勾选了Initialize this repository with a README，在git push的时候报错，我当时为了解决问题，强制推送git push -f origin master，总结的时候又查了一下发现可以先将远程pull下来再push git pull -r origin master MongoDBmongoDB手动启动服务：mongod –dbpath=D:\\Develop\\MongoDB\\Server\\3.4\\data\\db注册为windows服务：mongod.exe –logpath “D:\\Develop\\MongoDB\\Server\\3.4\\data\\log\\mongodb.log” –logappend –dbpath “D:\\Develop\\MongoDB\\Server\\3.4\\data\\db” –serviceName “MongoDB” –install安装未成功，解决办法：找到cmd.exe，右键以管理员身份运行，然后再执行上述注册服务的命令。 nodenpm install -g nn latest","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"从输入URL到页面加载完成到底发生了什么？","date":"2017-07-19T01:22:09.000Z","path":"2017/07/19/008/","text":"&emsp;&emsp;这应该是我开始学习前端之后看到的次数最多的一道面试题目，也是我最怕的一道题目了。计算机网络和硬件方面我还是个文盲，我对软件一直更感兴趣一点，对网络和硬件就比较心虚，寒暑假回家大爷大妈让我修电脑的时候，我只能无奈地一再强调自己是学软件的。为了更好地 为人民服务 学习前端，我准备从头到尾理清这道题，借此完成计算网络的攻坚克难战，顺便准备技术交流的素材。&emsp;&emsp;在我最开始的意识里，这个过程应该是在浏览器地址栏输入URL之后信息被送到了某处，然后获得回复，内容按照一定格式(前端要做的工作)展示在Web页面上。而事实上在电脑显示器后面在这短短的时间(网速好的话)内有太多看不到的过程发生了。 1.输入URL后浏览器做了什么我们先来理解一下URL是什么，它为我们做了什么 (1)URL Uniform Resource Locator 统一资源定位符URI（Uniform Resource Identifier) 统一资源标识符URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置），URL是URI的子集。URL的一般格式为(带方括号[]的为可选项)：protocol :// hostname[:port] / path / [;parameters][?query]#fragment URL由三部分组成：协议类型，主机名和路径及文件名。通过URL可以指定的主要有以下几种：http、ftp、gopher、telnet、file等。 1、protocol（协议）：指定使用的传输协议 file 资源是本地计算机上的文件。格式file:// ftp 通过 FTP访问资源。格式 FTP:// http 通过 HTTP 访问该资源。格式 HTTP:// https 通过安全的 HTTPS 访问该资源。格式 HTTPS:// mailto 资源为电子邮件地址，通过 SMTP 访问。格式 mailto: 2、hostname（主机名）：是指存放资源的服务器的域名系统 (DNS) 主机名或 IP 地址。有时，在主机名前也可以包含连接到服务器所需的用户名和密码（格式：username:password）。 3、port（端口号）：整数，可选，省略时使用方案的默认端口，各种传输协议都有默认的端口号，如http的默认端口为80。如果输入时省略，则使用默认端口号。有时候出于安全或其他考虑，可以在服务器上对端口进行重定义，即采用非标准端口号，此时，URL中就不能省略端口号这一项。 4、path（路径）：由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。 5、;parameters（参数）：这是用于指定特殊参数的可选项。 6、?query(查询)：可选，用于传递参数，可有多个参数，用“&amp;”符号隔开，每个参数的名和值用“=”符号隔开。 7、fragment，代表了资源内的一个位置。 在 URI 的末尾通过 hash mark（#）作为 fragment 的开头，其中#不属于 fragment 的值。1.#有别于?。?后面的查询字符串会被网络请求带上服务器，而 fragment 不会被发送的服务器；2.fragment 的改变不会触发浏览器刷新页面，但是会生成浏览历史（对IE 6和IE 7不成立）；3.fragment 会被浏览器根据文件媒体类型（MIME type）进行对应的处理；4.Google 的搜索引擎会忽略 # 及其后面的字符串。如果希望Ajax生成的内容被浏览引擎读取，可以使用”#!”5.JS中可以通过window.location.hash来读取或改变＃的值 (2)负责域名解析的DNS服务 Domain Name System 应用层DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务URL和DNS协议为我们标识了资源的地点，让我们知道去哪里请求需要的资源。 2.在传输过程中发生了什么Web采用HTTP协议作为规范，完成从客户端到服务器端的通信。HTTP协议 Hyper Text Transfer Protocol 超文本传输协议 应用层HTTP协议基于TCP/IP协议族进行网络通信。其中包括： (1)负责传输的IP协议 Internet Protocol 网际协议 网络层MAC地址 Media Acess Control Address使用ARP协议进行通信 (2)确保可靠性的TCP协议 Transmission Control Protocol 传输控制协议 传输层为什么说它是确保可靠性的呢，TCP协议为了准确无误的将数据送达目标处采用了三次握手three-way-handshaking策略TCP 协议的三次握手 – 用以确认数据传输正确，会重试到完整地完成为止。 TCP/IP传输流：作为发送端的客户端在应用层（HTTP协议）发出HTTP请求。为了传输方便在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在格格报文上打上标记序号及端口号后转发给网络层。在网络层（IP协议）增加作为通讯目的地的MAC地址后转发给数据链路层。接收端的服务器在数据链路层接收到数据，发送到网络层传输层一直到应用层。这时候接收端的服务器才真正收到了了客户端的HTTP请求。 HTTP请求由三部分组成，分别是：请求行、首部字段、报文主体请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。 请求方法有多种： 请求方法 说明 GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据 HEAD 请求获取由Request-URI所标识的资源的响应消息报头 PUT 请求服务器存储一个资源，并用Request-URI作为其标识 DELETE 请求服务器删除Request-URI所标识的资源 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求 在html页面中输入URL、访问超链接、form提交（当然也可以设置method为POST）等都是GET请求方法，比如本题“从输入URL到页面加载完成到底发生了什么？” GET和POST对比：GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。GET是幂等的POST：一般用于修改服务器上的资源，对所发送的信息没有限制。GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。然而，在以下情况中，请使用 POST 请求：无法使用缓存文件（更新服务器上的文件或数据库）；向服务器发送大量数据（POST 没有数据量限制）；发送包含未知字符的用户输入时，POST比GET更稳定也更可靠。 HTTP响应也是由三个部分组成，分别是：状态行、首部字段、报文主体状态行格式：HTTP-Version Status-Code Reason-Phrase CRLF其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。比如HTTP/1.1 200 OK 响应状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 响应状态代码 状态描述 说明 1xx 指示信息 表示请求已接收，继续处理 2xx 成功 表示请求已被成功接收、理解、接受 3xx 重定向 要完成请求必须进行更进一步的操作 4xx 客户端错误 请求有语法错误或请求无法实现 5xx 服务器端错误 服务器未能实现合法的请求 常见状态代码、状态描述、说明： 常见状态代码 状态描述 说明 200 OK 客户端请求成功 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized 请求未经授权，必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务 404 Not Found 请求资源不存在，eg：输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误 503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 从100到199范围的HTTP状态码是信息报告码。基于各种原因考虑，大多数情况下我们是很少看见这些代码的。首先，如果一个浏览器尝试访问一个网站，而网站返回这些代码时，它们往往都不会显示在屏幕上。它们只是浏览器使引用的内部码。另外，这些代码不常见的另外一个原因是起初HTTP标准不允许使用这一范围的状态码。就其本身而言，它们也一直没有被广泛地使用。 HTTP/1.1首部字段 通用首部字段 首部字段名 说明 Cache-Control 控制缓存的行为 Connection 逐跳首部、连接的管理 Date 创建报文的日期时间 Pragma 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知 请求首部字段 首部字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言（自然语言） Authorization Web认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在服务器 if-Match 比较实体标记（ETag） if-Modified-Since 比较资源的更新时间 if-None-Match 比较实体标记（与if-Match相反） if-Range 资源未更新时发送实体Byte的范围请求 if-Unmodified-Since 比较资源的更新时间（与if-Modified-Since相反） Max-Forwards 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中URI的原始获取方法 TE 传输编码的优先级 User-Agent HTTP客户端程序的信息 响应首部字段 首部字段名 说明 Accept-Ranges 是否接受字节范围请求 Age 推算资源创建经过时间 ETag 资源的匹配信息 Location 令客户端重定向至指定的URI Proxy-Authenticate 代理服务器对客户端的认证信息 Reter-After 对再次发起请求的时机要求 Server HTTP服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 实体首部字段 首部字段名 说明 Allow 资源可支持的HTTP方法 Content-Encoding 实体主体的适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小（单位：字节） Content-Location 替代对应资源的URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期的日期时间 Last-Modified 资源的最后修改日期时间 在这里同学问我Expires是缓存还是Cookie的失效时间。Expires是将资源失效的日期告知客户端。源服务器不希望缓存服务器对资源缓存时会将Expires字段写入与首部字段Date相同的时间值，就像当时看到的百度的示例。但当同时存在Cache-control的max-age会优先处理max-age指令，忽略掉Expires。max-age代表资源保存为缓存的最长时间。 响应的结果也同样利用TCP/IP通信协议向客户端回传。 这里我的同学帮我补充了一点：关于cookie的状态管理HTTP是无状态协议，他不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。Cookie会根据从服务器端发送的响应的报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后的到之前的状态信息。 还有一种服务端的机制——Session。Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Redis之类的来放 Session。区别：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式 3.请求到数据后浏览器做了什么当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：解析 —— HTML，CSS，JS渲染 —— 构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制（1）首先，浏览器渲染引擎从网络层取得请求的资源，一般以8kB大小分块传输。（2）HTML解析器对HTML文档进行解析，生成解析树。解析树是以DOM（文档对象模型 Document Object Model）元素以及属性为节点的树。它是HTML文档的对象表示，同时也是HTML元素面向外部(如Javascript)的接口。树的根部是”Document”对象。整个DOM和HTML文档几乎是一对一的关系。（3）遇到css标签解析CSS生成CSS规则树（4）浏览器通过遍历CSS规则树和DOM节点树创建一个渲染树（Render Tree）（5）页面布局和绘制 注意：渲染结束后，JavaScript下载后JS操作修改DOM、修改样式都会造成渲染树的重新布局和重绘。只要修改DOM或修改了元素的形状或大小，就会触发Reflow，单纯修改元素的颜色只需Repaint一下。 参考资料：《图解http》腾讯IMWeb知乎专栏what-happens-when6 Things You Should Know About Fragment URLs","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"爱你就像爱生命","date":"2017-07-16T11:48:49.000Z","path":"2017/07/16/007/","text":"你能建立良好的项目和解决问题，这才是最重要的，而你如何解决它们（所使用的工具）已经并将永远改变。If you can build good projects and solve problems then that’s all that matters, how you solve them (the tools) has and will always change. 珍惜生命 远离IE6","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"岁月轻狂","date":"2017-07-16T07:49:25.000Z","path":"2017/07/16/006/","text":"&emsp;&emsp;昨天整理了豆列，全是自己想买的东西。今天因为凯尔经的秘密打开豆瓣电影，发现大学四年真的看了好多动画电影，那时候雪姐和大静还有伢伢只要有好的片子就不会放过，最神奇的是雪姐总能找到好多久远的但是好看的片子，尤其是认识李晓龙之后。&emsp;&emsp;我还能清晰的记起从青科吃完饭走回去时风的温度、天空的颜色、青科电台放的那首《岁月轻狂》。看向我们宿舍那一块，建筑高高低低，礼堂的屋顶尖尖的，宿舍晾晒的衣服迎风飘扬着。青科操场那一片天空格外的开阔，颜色总是那么多彩，望出去能看到西院操场上的人和远处海边的高楼。在那条路上有一株合欢树，我和伢伢专门去看过它的花。快到东院后门那里有一整墙如瀑的爬山虎，四年来一年比一年生机勃勃。而那面高高的围墙，好像从来没看到过头。从夏天开始一直到初秋，后门有一块地会有花门一样的玫瑰，间或几只钻出铁网对路人say hello。进了后门通往二综路两侧是山樱花和榆叶李，开花的时候满树满树的欣喜，不开花的时候总是映衬得天空特别蓝。树与树之间的空隙里可以看到东院操场，青岛真的是气候宜人，而那里又是风景绝佳，离开时最舍不得的就是那里，四年来在哪里发生过太多故事，欢乐悲伤平静愤怒，见证了我的一切，又陪伴了我的四年，我总想回去看看，什么都不做，就想再走几圈看看远山看看日落。&emsp;&emsp;回忆着竟然想起，大一的冬天，想给强哥织条围巾，寒夜里站在大门口跟卖毛线的大姐学，零下好几度的天气手都冻僵了。可是到最后也没有织好看，后来暑假在家想重新织条，却怎么都想不起怎么起头了。 2016-08-15 18:57:36","tags":[{"name":"随笔","slug":"随笔","permalink":"https://wongyirong.github.io/tags/随笔/"}]},{"title":"时间并不会把每个人带到同一个位置","date":"2017-07-16T04:47:31.000Z","path":"2017/07/16/005/","text":"&emsp;&emsp;我姐上小学的时候，数学总是不及格，我比她小两级，每次我都笑话她，她就会说：我们数学难，等你上高年级你也考不及格。可是后来我上三年级四年级五年级六年级，成绩一直很好。时间并不会把每个人带到同样一个位置，决定位置高低的还是你自己啊。&emsp;&emsp;很多人喜欢在劝我的时候拿更差的人来做对比，这让我很不理解。一是我并不想和别人比，明明标准在那里，而我没达到而已。二是我只是陈述事实，不是消极难过，本就是不需要劝。&emsp;&emsp;每次这种时候我就会变成两个人，一个人耐心给她们解释I’m fine ，另一人在想我要这么多“朋友”干什么。事事嘘寒问暖有一个我妈，就够了。劝人的时候不要说一些违心的话，夸人的时候同样。既然是你的立场你就要时刻坚持，如果觉得说出来会伤害到别人，可以选择不说。我更喜欢耿直的朋友，他们让我觉得舒服。只是想法不同并不是要与你为敌，我们每个人都是有着独立思想的个体，我们成为朋友不过只是互相接纳互相包容的结果。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://wongyirong.github.io/tags/随笔/"}]},{"title":"那些话儿","date":"2017-07-15T13:21:16.000Z","path":"2017/07/15/004/","text":"&emsp;&emsp;我记性不好，又总是希望能记住生活中发生的听到的看到的所有事情，为此这些年一直坚持使用QQ空间留言板，用到都有人开始嘲笑我才慢慢转移阵地。后来收了workflow和印象笔记后，我开始每天和采蘑菇的小女孩似的，把喜欢的句子说过的话想珍藏的一切复制了往印象笔记里粘，还会时不时打开印象笔记一本满足的清点满筐的“蘑菇”。&emsp;&emsp;话特别多想法特别多的我在别人眼里越来越奇怪了，而我不能理解的人和事情也越来越多，篮子里采了那么多蘑菇却只能自己偶尔的拿出来看看，晒不到太阳不可避免的开始发霉了。人总是期待被理解，被认可，孤独也不过是宁为玉碎不为瓦全。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://wongyirong.github.io/tags/随笔/"}]},{"title":"我的博客简介","date":"2017-07-15T10:28:20.000Z","path":"2017/07/15/003/","text":"&emsp;&emsp;之前一直想建一个自己的网站，本来打算的是买一个阿里云或者腾讯云的服务器，自己用node+vue+MongoDB前后端分离一整套做出来，但以我现在的能力又任重道远。前几日发现了GitPages，就打算利用Pages做点页面展示。&emsp;&emsp;昨天听Litten的直播课，听的时候一直感叹他的优秀，专门记住了名字。今天按原计划建我的博客，对比了一些流行的静态博客框架后决定采用hexo，主要是看到hexo是node.js写的，感觉有亲切感。&emsp;&emsp;找了个教程看着做，在选主题的时候看到Litten的名字，简直闪闪发光！啊，人生何处不相逢。&emsp;&emsp;过程中还是遇到很多问题，午饭后对着Litten的github和hexo的官方文档才搞清楚。晚饭后本来要做编程题，可是看Litten的博客有个相册功能，我又很想试试。","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"陌生人啊感谢你的好意","date":"2017-07-15T08:36:20.000Z","path":"2017/07/15/002/","text":"&emsp;&emsp;昨天在网上看IMWeb的笔试直播课，我才发现愚蠢而固步自封的我离前端工程师的路太远了。而留给我赶路的时间却不多，我知道自己必须停下来，记下这些感动，记住这些的来之不易的相逢。我一直后悔很多过去的事情，而过去的时光不再，当下也是未来会后悔的时刻啊。&emsp;&emsp;人生有很多弯路，明明别人一早就告诉你了，可你没走过你总不肯相信那真的是条弯路。也许不是现在我可能不会报这个班，如果不是现在我可能并不能恰好的体会这些，让我后悔的过去、走过的弯路其实都是最好的安排。&emsp;&emsp;昨天更大的收获是认识了一个真正优秀的前端工程师，我确信我爱自己的选择，但我真的离我想成为的人有很远的距离。陌生人啊，感谢你的好意你的真心，能在这一刻幡然醒悟，睁开双眼看世界，我应该感激。我的人生真是幸运，那些驼背走在路上唉声叹气的人，那些碌碌无为浑浑度日的人，他们都不曾遇到我这样的好运气。真感激，我是我，我遇到过这么多好人。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://wongyirong.github.io/tags/随笔/"}]},{"title":"裙角飞扬的日子","date":"2016-08-10T03:24:23.000Z","path":"2016/08/10/001/","text":"我的wordpress的一些记录 明明快好了，昨晚一直不困，就一直熬到两点多才睡，早上实在是醒不来，头也痛，鼻塞更甚，咳嗽了一上午。中午睡醒竟有种熟悉的发烧的感觉，说不来的难受，在床上又呆了一个小时才好一些。 啊，我开通了CSDN博客，哈哈哈2016-08-28 19:09:59 病来如山倒 20160825有咽炎，扁桃体炎，昨天和前几天有微微的嗓子痛，没在意，昨天晚上洗冷水，洗完就鼻塞难受，早上起来咽痛，轻微，清涕。20160826白天喝了很多红糖可乐姜茶，晚上咽干严重，鼻塞更甚。今天早上买了云南白药《风寒感冒颗粒》，效果比较明显，咽干好一些，鼻塞，流涕好一些，头痛也好了些，但是还是打喷嚏。明天再看效果。2016-08-25 08:59:51 记录 放在回忆里，不如忘记。醒来收到微信速来宝的消息，领了发现是之前东野兴冲冲给我预定的大冰的新作，我不知该说啥，自从当年亲眼见过他，我竟然感觉自己看穿了他，对他越来越不屑。东野要送我我也不知道如何拒绝，拿到翻开的兴趣都没有，希望东野能见谅，当然是建立在她不知道的前提下。我换了新号码竟然还能收到，要是没收到就好了。2016-08-16 14:44:02 你的善良必须有点锋芒–不然就等于零。2016-08-11 09:19:11 翻出14年7月到9月的一些记录，发现也许你做的对。我走过很多弯路，我做过很多错事，如果只是记忆模糊就当它不存在这是多么自欺欺人，问题是我明明走过不止一个弯路，仍不知悔改。2016-08-10 16:34:05 明白那么多道理，仍然不想好好地过这一生。 最近有些压抑，人生的路要走向何方，我到底怎么了，我以后要怎么办，很多问题想不清，想梳理明白，各大社交网站越玩越寂寞，想静静的在自己的世界想清楚。2016-08-10 11:24:23 我的wordpress纪念","tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://wongyirong.github.io/tags/碎碎念/"}]}]