[{"title":"DOM","date":"2017-08-10T05:11:53.000Z","path":"2017/08/10/023/","text":"1、什么是DOM? DOM，文档对象模型（Document Object Model）。DOM是 W3C（万维网联盟）的标准，DOM定义了访问HTML和XML文档的标准。在W3C的标准中，DOM是独于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。 W3C DOM由以下三部分组成： 核心DOM 针对任何结构化文档的标准模型XML DOM 针对XML文档的标准模型HTML DOM 针对HTML文档的标准模型 2、DOM的作用网页由HTML来搭建结构，通过css来定义网页的样式，JavaScript赋予了页面的行为，同时我们可以通过JavaScript与页面进行交互，实现页面的动画效果等。而JavaScript是通过ECMAScript标准编写程序让浏览器来解析，利用ECMAScript，我们可以通过BOM对象（即browser object model）来操作浏览器窗口、浏览器导航对象(navigator)、屏幕分辨率(screen)、浏览器历史(history)、cookie等等。要实现页面的动态交互和效果，操作HTML才是核心。DOM给我们提供了用程序来动态控制HTML的接口，也就是早期的DHTML的概念。DOM处在javascript赋予HTML具备动态交互和效果的能力的核心地位上。 3、DOM0、DOM1、DOM2、DOM3的区别3.1、DOM0与DHTML DHTML是Dynamic HTML（动态HTML）的简称。DHTML并不是一项新技术，而是将HTML、CSS、JavaScript技术组合的一种描述。即： 利用HTML把网页标记为各种元素利用CSS设置元素样式及其显示位置利用JavaScript操控页面元素和样式 利用DHTML，看起来可以很容易的控制页面元素，并实现一些原本很复杂的效果（如：通过改变元素位置实现动画）。但事实并非如此，因为没有规范和标准，浏览器对相同功能的实现完全不一样。为了保持程序的兼容性，程序员必须写一些探查代码以检测JavaScript是运行于哪种浏览器之下，并提供与之对应的脚本。 我们在阅读DOM标准的时候，经常会看到DOM0级这样的字眼，实际上DOM0级这个标准是不存在的。所谓DOM0级只是DOM历史坐标系中的一个参照点而已，具体地说DOM0级就是指IE4.0和Netscape navigator4.0最初支持的那个DHTML。 3.2、DOM1的出现 W3C于1998年10月完成了第一级DOM，即：DOM1。W3C将DOM定义为一个与平台和编程语言无关的接口，通过这个接口程序和脚本可以动态的访问和修改文档的内容、结构和样式。DOM1级主要定义了HTML和XML文档的底层结构。在DOM1中，DOM由两个模块组成：DOM Core（DOM核心）和DOM HTML。其中，DOM Core规定了基于XML的文档结构标准，通过这个标准简化了对文档中任意部分的访问和操作。DOM HTML则在DOM核心的基础上加以扩展，添加了针对HTML的对象和方法，比如：JavaScript中的Document对象。 3.3、DOM2 在DOM1的基础上DOM2引入了更多的交互能力，也支持了更高级的XML特性。DOM2将DOM分为更多具有联系的模块。DOM2级在原来DOM的基础上又扩充了鼠标、用户界面事件、范围、遍历等细分模块，而且通过对象接口增加了对CSS的支持。DOM1级中的DOM核心模块也经过扩展开始支持XML命名空间。在DOM2中引入了下列模块，在模块包含了众多新类型和新接口： DOM视图（DOM Views）：定义了跟踪不同文档视图的接口DOM事件（DOM Events）：定义了事件和事件处理的接口DOM样式（DOM Style）：定义了基于CSS为元素应用样式的接口DOM遍历和范围（DOM Traversal and Range）：定义了遍历和操作文档树的接口 完整的DOM2标准(图片来自百度百科): 3.4、DOM3 DOM3级：进一步扩展了DOM，引入了以统一方式加载和保存文档的方法，它在DOM Load And Save这个模块中定义；同时新增了验证文档的方法，是在DOM Validation这个模块中定义的。 DOM3进一步扩展了DOM，在DOM3中引入了以下模块： DOM加载和保存模块（DOM Load and Save）：引入了以统一方式加载和保存文档的方法DOM验证模块（DOM Validation）：定义了验证文档的方法DOM核心的扩展（DOM Style）：支持XML 1.0规范，涉及XML Infoset、XPath和XML Base 4、认识DOMDOM可以将任何HTML描绘成一个由多层节点构成的结构。节点分为12种不同类型，每种类型分别表示文档中不同的信息及标记。每个节点都拥有各自的特点、数据和方法，也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。 先看一张w3school上面的一张图: HTML文档可以说由节点构成的集合，DOM节点有: 1.元素节点：上图中HTML、body、p等都是元素节点，即标签。2.文本节点:向用户展示的内容，如li标签中的JavaScript、DOM、CSS等文本。3.属性节点:元素属性，如a标签的链接属性href=”http://www.baidu.com&quot;。 5、DOM节点类型DOM1级定义了一个Node接口，这个Node接口在JavaScript中是作为Node类型来实现的。除了IE以外，其他所有浏览器都可以访问这个类型。每个节点都有一个nodeType属性，用于表明节点的类型。节点类型通过定义数值常量和字符常量两种方式来表示，IE只支持数值常量。节点类型一共有12种，这里介绍常用的7种类型。如下图： (1)Element(元素节点)：是组成文档树的重要部分，它表示了HTML、xml文档中的元素。通常元素因为有子元素、文本节点或者两者的结合，元素节点是唯一能够拥有属性的节点类型。 例子中的:HTML、heade、meta、title、body、div、ul、li、script都属于Element(元素节点); (2)Attr(属性节点)：代表了元素中的属性，因为属性实际上是附属于元素的，因此属性节点不能被看做是元素的子节点。因而在DOM中属性没有被认为是文档树的一部分。换句话说，属性节点其实被看做是包含它的元素节点的一部分，它并不作为单独的一个节点在文档树中出现。 例子中的:lang、charset、id、class都属于Attr(属性节点); (3)Text(文本节点)：是只包含文本内容的节点，在xml中称为字符数据，它可以由更多的信息组成，也可以只包含空白。在文档树中元素的文本内容和属性的文本内容都是由文本节点来表示的。 例子中的:DocumentFragment文档片段节点、test1、test2、元素节点之后的空白区域都属于Text(文本节点); (4)Comment(注释节点)：表示注释的内容 例子中的:tip区域 都属于Comment(注释节点); (5)Document(文档节点) ：是文档树的根节点，它是文档中其他所有节点的父节点。要注意的是，文档节点并不是HTML、xml文档的根元素，因为在xml文档中，处理指令、注释等内容可以出现在根元素之外，所以我们在构造DOM树的时候，根元素并不适合作为根节点，因此就有了文档节点，而根元素是作为文档节点的子节点出现的。 例子中的：!DOCTYPE HTML、HTML作为Document(文档节点)的子节点出现; (6)DocumentType(文档类型节点)：每一个Document都有一个DocumentType属性，它的值或者是null，或者是DocumentType对象。比如声明文档类型时!doctype HTML就是文档类型节点。 例子中的：!DOCTYPE HTML 就属于DocumentType(文档类型节点); (7)DocumentFragment(文档片段节点)：是轻量级的或最小的Document对象，它表示文档的一部分或者是一段，不属于文档树。不过它有一种特殊的行为，该行为使得它非常有用。比如：当请求把一个DocumentFragment节点插入到文档的时候，插入的不是DocumentFragment自身，而是它的所有的子孙节点。这使得DocumentFragment成了有用的占位符，暂时存放那些一次插入文档的节点，同时它还有利于实现文档的剪切、复制和粘贴等操作。 例子中的:var frag = document.createDocumentFragment();frag就属于DocumentFragment(文档片段节点)。createdocumentfragment()方法创建了一虚拟的节点对象，包含所有属性和方法。 7、DOM的nodeType、nodeName、nodeValue根据实验，得出以下汇总表格: 8、domReady8.1、什么是domReady？ HTML是一种标记语言，它告诉我们这个页面有什么内容，但行为交互是需要通过DOM操作来实现的。HTML标签要通过浏览器解析才会变成DOM节点，当我们向地址栏传入一个url后到页面加载完成，在这期间就有一个DOM节点构建的过程。节点是以树的形式组织的，当页面上所有的HTML都转换为节点以后，就叫做DOM树构建完毕，简称为domReady。 8.2、那么浏览器是如何将HTML标签解析变成DOM节点的呢？ 实际上浏览器是通过渲染引擎来实现的，默认情况下渲染引擎可以显示HTML、xml文档及图片，渲染引擎的主要用途，即是将css格式化的HTML和图片在浏览器上进行显示。 8.3、浏览器渲染引擎的基本渲染流程 渲染引擎首先通过网络获得所请求文档的内容，通常以8k分块的方法来完成： 上图就是webkit内核的HTML渲染的基本过程，但这并不包含解析过程中浏览器加载外部资源，比如图片、脚本、iframe等的一些过程。上面的4步仅仅是HTML结构的渲染过程。而外部资源的加载在HTML结构的渲染过程中是贯彻始终的，即便绘制DOM节点已经完成，而外部资源仍然可能正在加载或者尚未加载。 8.4、domReady的实现策略 上面的代码实例中，并没有考虑domReady，程序也能正常运行，因为我们把javascript代码写在了body元素最后的位置。浏览器是从上到下，从左向右渲染HTML元素的，这样实例中的js代码一定在domReady之后去执行的。但在编写大型项目的时候，js文件往往非常多，而且之间会相互调用，大多数都是外部引用的。这种方式无法保证不管逻辑代码写在哪里，都是等到domReady之后去执行。 1.原来比较常用的是window的onload事件，而该事件的实际效果是：当页面解析/DOM树建立完成，并完成了诸如图片、脚本、样式表甚至是iframe中所有资源的下载后才触发的。这对于很多实际的应用而言有点太“迟”了，比较影响用户体验。 2.jquery中的$(document).ready(function(){})方法。 3.为了解决window.onload的短板，w3c新增了一个DOMContentLoaded事件。在页面的DOM树创建完成后（也就是HTML解析第一步完成）即触发，而无需等待其他资源的加载。 IE8（包括）之前版本由于不支持符合W3C规范的DOMContentLoaded事件，所以需要用hack实现兼容。即domReady实现策略： 1.支持DOMContentLoaded事件的，就使用DOMContentLoaded事件。当初始HTML文档被完全加载和解析时，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架完成加载。2.不支持的使用著名Hack兼容。兼容原理大概就是通过IE中的document.documentElement.doScroll(‘left’)来判断DOM树是否创建完毕。 根据以上策略使用原生JavaScript实现domReady。 各个主流框架domReady的实现：点击我查看 8.5、domReady与window.onload onload事件是要在所有请求都完成之后才执行，而domReady在加载完dom树之后就能执行，所以domReady比onload执行时间更早。 参考资料：深入浅出DOM基础W3C DOM教程","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"HTML DOM参考手册","date":"2017-08-09T11:11:53.000Z","path":"2017/08/09/022/","text":"在 HTML DOM （文档对象模型）中，每个部分都是节点： 文档本身是文档节点所有 HTML 元素是元素节点所有 HTML 属性是属性节点HTML 元素内的文本是文本节点注释是注释节点 HTML DOM Document 对象 方法 描述 getElementById() 返回对拥有指定 id 的第一个对象的引用 getElementsByName() 返回带有指定名称的NodeList getElementsByTagName() 返回包含带有指定标签名称的所有元素的NodeList getElementsByClassName() 返回包含带有指定类名的所有元素的NodeList createAttribute() 创建拥有指定名称的属性节点，并返回新的 Attr 对象 createElement() 创建元素节点 createTextNode() 创建文本节点 HTML DOM Element 对象在 HTML DOM 中，Element 对象表示 HTML 元素。Element 对象可以拥有类型为元素节点、文本节点、注释节点的子节点。NodeList 对象表示节点列表，比如 HTML 元素的子节点集合。 方法 描述 appendChild() 向元素添加新的子节点，作为最后一个子节点 removeChild() 从元素中移除子节点 getAttribute() 返回元素节点的指定属性值 setAttribute() 把指定属性设置或修改为指定的值 removeAttribute() 从元素中移除指定属性 属性是节点（HTML 元素）的值，可以获取或设置。 属性 描述 innerHTML 设置或返回元素的内容 attributes 返回元素属性的 NamedNodeMap childNodes 返回元素子节点的 NodeList parentNode 返回元素的父节点 nodeName 返回元素的名称 nodeType 返回元素的节点类型 nodeValue 设置或返回元素值 Element.outerHTML 获取描述包括其后代的元素的序列化HTML片段Node.innerText 是一个表示一个节点及其后代的“渲染”文本内容的属性。HTMLElement.outerText是一个非标准的属性。作为一个得到器，它返回相同的值作为Node.innerText. 作为一个设置器，它将删除当前节点并将其替换为给定的文本. 1.nodeName 属性 nodeName 属性规定节点的名称，只读如果节点是 元素节点，则 nodeName 属性返回 标签名入股节点是 属性节点，则 nodeName 属性返回 属性的名称对于其他节点类型，nodeName 属性返回不同节点类型的不同名称。 2.nodeValue 属性 nodeValue 属性规定节点的值。元素节点的 nodeValue 是 undefined 或 null文本节点的 nodeValue 是 文本本身属性节点的 nodeValue 是 属性值 3.nodeType 属性 nodeType 属性返回以数字值返回指定节点的节点类型，只读。如果节点是 元素节点，则 nodeType 属性将返回 1如果节点是 属性节点，则 nodeType 属性将返回 2 HTML DOM Attribute 对象在 HTML DOM 中，Attr 对象表示 HTML 属性。HTML 属性始终属于 HTML 元素。NamedNodeMap 对象表示元素属性节点的无序集合。","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"十大排序算法【转】","date":"2017-08-09T07:22:53.000Z","path":"2017/08/09/020/","text":"原文来自Damonare的个人博客 排序算法说明（1）排序的定义：对一序列对象根据某个关键字进行排序； 输入：n个数：a1,a2,a3,…,an输出：n个数的排列:a1’,a2’,a3’,…,an’，使得a1’&lt;=a2’&lt;=a3’&lt;=…&lt;=an’。 （2）对于评述算法优劣术语的说明 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成；外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度: 一个算法执行所耗费的时间。空间复杂度: 运行完一个程序所需内存的大小。 关于时间空间复杂度的更多了解请戳这里，或是看《大话数据结构》，通俗易懂。（3）排序算法图片总结 (图片来源于网络): 排序对比： 图片名词解释：n: 数据规模k:“桶”的个数In-place: 占用常数内存，不占用额外内存Out-place: 占用额外内存 排序分类： 1.冒泡排序（Bubble Sort） 好的，开始总结第一个排序算法，冒泡排序。我想对于它每个学过C语言的都会了解的吧，这可能是很多人接触的第一个排序算法。 (1)算法描述 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 (2)算法描述和实现具体算法描述如下： .比较相邻的元素。如果第一个比第二个大，就交换它们两个； .对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； .针对所有的元素重复以上的步骤，除了最后一个； .重复步骤1~3，直到排序完成。 JavaScript代码实现： function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 改进冒泡排序： 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。 改进后算法如下:function bubbleSort2(arr) &#123; console.time('改进后冒泡排序耗时'); var i = arr.length-1; //初始时,最后位置保持不变 while ( i&gt; 0) &#123; var pos= 0; //每趟开始时,无记录交换 for (var j= 0; j&lt; i; j++) if (arr[j]&gt; arr[j+1]) &#123; pos= j; //记录交换的位置 var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; &#125; i= pos; //为下一趟排序作准备 &#125; console.timeEnd('改进后冒泡排序耗时'); return arr;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bubbleSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。 改进后的算法实现为:function bubbleSort3(arr3) &#123; var low = 0; var high= arr.length-1; //设置变量的初始值 var tmp,j; console.time('2.改进后冒泡排序耗时'); while (low &lt; high) &#123; for (j= low; j&lt; high; ++j) //正向冒泡,找到最大者 if (arr[j]&gt; arr[j+1]) &#123; tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; &#125; --high; //修改high值, 前移一位 for (j=high; j&gt;low; --j) //反向冒泡,找到最小者 if (arr[j]&lt;arr[j-1]) &#123; tmp = arr[j]; arr[j]=arr[j-1];arr[j-1]=tmp; &#125; ++low; //修改low值,后移一位 &#125; console.timeEnd('2.改进后冒泡排序耗时'); return arr3;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bubbleSort3(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 三种方法耗时对比： 由图可以看出改进后的冒泡排序明显的时间复杂度更低，耗时更短了。 冒泡排序动图演示: (3)算法分析 最佳情况：T(n) = O(n) 当输入的数据已经是正序时（都已经是正序了，为毛何必还排序呢….） 最差情况：T(n) = O(n2) 当输入的数据是反序时(卧槽，我直接反序不就完了….) 平均情况：T(n) = O(n2) 2.选择排序（Selection Sort） 表现最稳定的排序算法之一(这个稳定不是指算法层面上的稳定哈，相信聪明的你能明白我说的意思2333)，因为无论什么数据进去都是O(n²)的时间复杂度…..所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。 (1)算法简介 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 (2)算法描述和实现n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： .初始状态：无序区为R[1..n]，有序区为空； .第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； .n-1趟结束，数组有序化了。 Javascript代码实现: function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; console.time('选择排序耗时'); for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数 minIndex = j; //将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; console.timeEnd('选择排序耗时'); return arr;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 选择排序动图演示： (3)算法分析 最佳情况：T(n) = O(n2) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2) 3.插入排序（Insertion Sort） 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了….. (1)算法简介 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 (2)算法描述和实现一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： .从第一个元素开始，该元素可以认为已经被排序； .取出下一个元素，在已经排序的元素序列中从后向前扫描； .如果该元素（已排序）大于新元素，将该元素移到下一位置； .重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； .将新元素插入到该位置后； .重复步骤2~5。 Javascript代码实现: function insertionSort(array) &#123; if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; console.time('插入排序耗时：'); for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i]; var j = i - 1; while (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123; array[j + 1] = array[j]; j--; &#125; array[j + 1] = key; &#125; console.timeEnd('插入排序耗时：'); return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125; 改进插入排序： 查找插入位置时使用二分查找的方式 function binaryInsertionSort(array) &#123; if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; console.time('二分插入排序耗时：'); for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i], left = 0, right = i - 1; while (left &lt;= right) &#123; var middle = parseInt((left + right) / 2); if (key &lt; array[middle]) &#123; right = middle - 1; &#125; else &#123; left = middle + 1; &#125; &#125; for (var j = i - 1; j &gt;= left; j--) &#123; array[j + 1] = array[j]; &#125; array[left] = key; &#125; console.timeEnd('二分插入排序耗时：'); return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 改进前后对比： 插入排序动图演示: (3)算法分析 最佳情况：输入数组按升序排列。T(n) = O(n) 最坏情况：输入数组按降序排列。T(n) = O(n2) 平均情况：T(n) = O(n2) 4.希尔排序（Shell Sort） 1959年Shell发明；第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序 (1)算法简介 希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。 (2)算法描述和实现先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： . 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； .按增量序列个数k，对序列进行k 趟排序； .每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 Javascript代码实现： function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; console.time('希尔排序耗时:'); while(gap &lt; len/5) &#123; //动态定义间隔序列 gap =gap*5+1; &#125; for (gap; gap &gt; 0; gap = Math.floor(gap/5)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123; arr[j+gap] = arr[j]; &#125; arr[j+gap] = temp; &#125; &#125; console.timeEnd('希尔排序耗时:'); return arr;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(shellSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 希尔排序图示： （3）算法分析 最佳情况：T(n) = O(nlog2 n) 最坏情况：T(n) = O(nlog2 n) 平均情况：T(n) =O(nlog n) 5.归并排序（Merge Sort） 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。 (1)算法简介 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 (2)算法描述和实现具体算法描述如下： .把长度为n的输入序列分成两个长度为n/2的子序列； .对这两个子序列分别采用归并排序； .将两个排序好的子序列合并成一个最终的排序序列。 Javscript代码实现: function mergeSort(arr) &#123; //采用自上而下的递归方法 var len = arr.length; if(len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right)&#123; var result = []; console.time('归并排序耗时'); while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); console.timeEnd('归并排序耗时'); return result;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(mergeSort(arr)); 归并排序动图演示: (3)算法分析 最佳情况：T(n) = O(n) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 6.快速排序（Quick Sort） 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。 (1)算法简介 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 (2)算法描述和实现快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： .从数列中挑出一个元素，称为 “基准”（pivot）； .重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； .递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 Javascript代码实现： /*方法说明：快速排序@param array 待排序数组*///方法一function quickSort(array, left, right) &#123; console.time('1.快速排序耗时'); if (Object.prototype.toString.call(array).slice(8, -1) === 'Array' &amp;&amp; typeof left === 'number' &amp;&amp; typeof right === 'number') &#123; if (left &lt; right) &#123; var x = array[right], i = left - 1, temp; for (var j = left; j &lt;= right; j++) &#123; if (array[j] &lt;= x) &#123; i++; temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; quickSort(array, left, i - 1); quickSort(array, i + 1, right); &#125; console.timeEnd('1.快速排序耗时'); return array; &#125; else &#123; return 'array is not an Array or left or right is not a number!'; &#125;&#125;//方法二var quickSort2 = function(arr) &#123; console.time('2.快速排序耗时'); if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125;console.timeEnd('2.快速排序耗时'); return quickSort2(left).concat([pivot], quickSort2(right));&#125;;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(quickSort(arr,0,arr.length-1));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]console.log(quickSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 快速排序动图演示： (3)算法分析 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(nlogn) 7.堆排序（Heap Sort） 堆排序可以说是一种利用堆的概念来排序的选择排序。 (1)算法简介 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 (2)算法描述和实现具体算法描述如下： .将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； .将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； .由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 Javascript代码实现： /*方法说明：堆排序@param array 待排序数组*/function heapSort(array) &#123; console.time('堆排序耗时'); if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; //建堆 var heapSize = array.length, temp; for (var i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i--) &#123; heapify(array, i, heapSize); &#125; //堆排序 for (var j = heapSize - 1; j &gt;= 1; j--) &#123; temp = array[0]; array[0] = array[j]; array[j] = temp; heapify(array, 0, --heapSize); &#125; console.timeEnd('堆排序耗时'); return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125;/*方法说明：维护堆的性质@param arr 数组@param x 数组下标@param len 堆大小*/function heapify(arr, x, len) &#123; if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' &amp;&amp; typeof x === 'number') &#123; var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp; if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123; largest = l; &#125; if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123; largest = r; &#125; if (largest != x) &#123; temp = arr[x]; arr[x] = arr[largest]; arr[largest] = temp; heapify(arr, largest, len); &#125; &#125; else &#123; return 'arr is not an Array or x is not a number!'; &#125;&#125;var arr=[91,60,96,13,35,65,46,65,10,30,20,31,77,81,22];console.log(heapSort(arr));//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96] 堆排序动图演示： (3)算法分析 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 8.计数排序（Counting Sort） 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 (1)算法简介 计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。 (2)算法描述和实现具体算法描述如下： . 找出待排序的数组中最大和最小的元素； . 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； . 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； . 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 Javascript代码实现： function countingSort(array) &#123; var len = array.length, B = [], C = [], min = max = array[0]; console.time('计数排序耗时'); for (var i = 0; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1; &#125; for (var j = min; j &lt; max; j++) &#123; C[j + 1] = (C[j + 1] || 0) + (C[j] || 0); &#125; for (var k = len - 1; k &gt;= 0; k--) &#123; B[C[array[k]] - 1] = array[k]; C[array[k]]--; &#125; console.timeEnd('计数排序耗时'); return B;&#125;var arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];console.log(countingSort(arr)); //[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9] JavaScript动图演示：、 (3)算法分析 当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。 最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n+k) 9.桶排序（Bucket Sort） 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 (1)算法简介 桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排 (2)算法描述和实现具体算法描述如下： .设置一个定量的数组当作空桶； .遍历输入数据，并且把数据一个一个放到对应的桶里去； .对每个不是空的桶进行排序； .从不是空的桶里把排好序的数据拼接起来。 Javascript代码实现: /*方法说明：桶排序@param array 数组@param num 桶的数量*/function bucketSort(array, num) &#123; if (array.length &lt;= 1) &#123; return array; &#125; var len = array.length, buckets = [], result = [], min = max = array[0], regex = '/^[1-9]+[0-9]*$/', space, n = 0; num = num || ((num &gt; 1 &amp;&amp; regex.test(num)) ? num : 10); console.time('桶排序耗时'); for (var i = 1; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; &#125; space = (max - min + 1) / num; for (var j = 0; j &lt; len; j++) &#123; var index = Math.floor((array[j] - min) / space); if (buckets[index]) &#123; // 非空桶，插入排序 var k = buckets[index].length - 1; while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; array[j]) &#123; buckets[index][k + 1] = buckets[index][k]; k--; &#125; buckets[index][k + 1] = array[j]; &#125; else &#123; //空桶，初始化 buckets[index] = []; buckets[index].push(array[j]); &#125; &#125; while (n &lt; num) &#123; result = result.concat(buckets[n]); n++; &#125; console.timeEnd('桶排序耗时'); return result;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bucketSort(arr,4));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 桶排序图示（图片来源网络）： 关于桶排序更多 (3)算法分析 桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n2) 10.基数排序（Radix Sort） 基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数； (1)算法简介 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。 (2)算法描述和实现具体算法描述如下： .取得数组中的最大数，并取得位数； .arr为原始数组，从最低位开始取每个位组成radix数组； .对radix进行计数排序（利用计数排序适用于小范围数的特点）； Javascript代码实现： /** * 基数排序适用于： * (1)数据范围较小，建议在小于1000 * (2)每个数值都要大于等于0 * @author xiazdong * @param arr 待排序数组 * @param maxDigit 最大位数 *///LSD Radix Sortfunction radixSort(arr, maxDigit) &#123; var mod = 10; var dev = 1; var counter = []; console.time('基数排序耗时'); for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; for(var j = 0; j &lt; arr.length; j++) &#123; var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]== null) &#123; counter[bucket] = []; &#125; counter[bucket].push(arr[j]); &#125; var pos = 0; for(var j = 0; j &lt; counter.length; j++) &#123; var value = null; if(counter[j]!=null) &#123; while ((value = counter[j].shift()) != null) &#123; arr[pos++] = value; &#125; &#125; &#125; &#125; console.timeEnd('基数排序耗时'); return arr;&#125;var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(radixSort(arr,2)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 基数排序LSD动图演示： (3)算法分析 最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k) 基数排序有两种方法： MSD 从高位开始进行排序 LSD 从低位开始进行排序 基数排序 vs 计数排序 vs 桶排序 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶 计数排序：每个桶只存储单一键值 桶排序：每个桶存储一定范围的数值 参考链接sorts","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"到底什么是标准和怪异","date":"2017-08-07T02:27:53.000Z","path":"2017/08/07/017/","text":"在标准模式下，一个块的总宽度=width+margin(左右)+padding(左右)+border(左右)在怪异模式下，一个块的总宽度=width+margin（左右）（既width已经包含了padding和border值） .con_box&#123; box-sizing: content-box; width: 100px; height: 100px; padding: 10px; margin: 50px; border: 10px solid green; background: red;&#125; 在线演示截图：.ie_box&#123; box-sizing: border-box; width: 100px; height: 100px; border: 10px solid green; padding: 10px; margin: 50px; background: red;&#125; 在线演示截图：","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"DOM事件","date":"2017-08-07T01:47:53.000Z","path":"2017/08/07/016/","text":"JavaScript与HTML之间的交互式通过事件实现的。事件就是文档或者浏览器窗口中发生的一些特定的交互瞬间。 事件流即事件传播（event propagation），描述的是从页面接收事件的顺序。IE的是事件冒泡流，Netcape是事件捕获流。 1.事件冒泡IE的事件流叫做事件冒泡（event bubbing），即事件最开始由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播至较为不具体的那个节点（文档）。IE9等会一直冒泡到window对象。 2.事件捕获Netcape提出的另一种事件流叫做事件捕获（event capturing）。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。目前现代浏览器（IE9、chrome等）都支持这种这种事件流模型。但因为老版本不支持，很少使用。 DOM事件流“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。IE9等都会在捕获阶段触发事件对象上的事件。结果就是有两个机会在目标对象上面操作事件。IE8之下不支持DOM事件流。 事件处理程序事件处理程序（event handler）或事件监听程序（event listener）是处理或者响应事件的函数。处理事件程序的名字以”on”开头，比如click事件的事件处理程序就是onclick 1.HTML事件处理程序某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定。这个特性的值应该是能够执行的JavaScript代码。&lt;input type=\"button\" value=\"HTML事件处理程序\" id=\"btn1\" onclick=\"showMes()\"&gt; 缺点1.时差问题：使用try-catch块捕捉错误。onclick=”try { showMessage() ;} catch(ex) {}”2.程序的作用域链在不同浏览器中会导致不同结果3.HTML和JS代码耦合紧密 2.DOM0级事件处理程序通过JS指定时间处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。首先要取得一个要操作的对象的引用。每个元素（包括window和document）都有自己的事件处理程序属性，这些属性通常全部小写，例如onclick。将这种属性的值设置为一个函数就可以指定事件处理程序。var btn2 = document.getElementById(\"btn2\");btn2.onclick = function() &#123; alert(\"这是通过DOM0级添加的事件\");&#125;; 优点:比较简单，跨浏览器的优势事件处理程序在元素的作用域中运行，this指向当前元素。会在事件流的冒泡阶段被处理删除事件处理程序：btn.onclick = null; 3.DOM2级事件处理程序DOM2级事件定义了两个方法：用于处理指定和删除事件处理程序的操作addEventListener和removeEventListener。接收3个参数，要处理的事件名称（不包含on）、作为事件处理程序的函数和一个布尔值。如果为true，表示在捕获时执行事件处理函数；如果为false，表示在冒泡阶段调用事件处理程序。大多数情况下用false。 addEventListener()添加的只能用removeEventListener()删除，而且参数都要一致。好处：可以添加多个事件处理程序。先添加先执行。问题：匿名函数无法移除。 var handler = function()&#123; alert(this.id);&#125;;btn.addEventListener(\"click\", handler, false);btn.removeEventListener(\"click\", handler, false); 4.IE事件处理程序attachEvent()添加事件detachEvent()删除事件接收两个参数：事件处理程序的名称（有on）和事件处理程序的函数 没有第三个参数，是因为IE8及更早版本只支持事件冒泡，默认添加到冒泡阶段注意：使用DOM方法时，事件会在所属元素的作用域内运行；使用attachEvent()方法，事件处理程序会在全局作用域运行，this等于window。好处：可以添加多个事件处理程序。后添加先执行。问题：匿名函数无法移除。支持IE事件处理的有IE和Opera var handler = function()&#123; alert(this.id);&#125;;btn.attachEvent (“onclick”, handler);btn.detachEvent (“onclick”, handler); 5.跨浏览器的事件处理程序创建一个对象eventUtil，拥有两个方法。addHandler(要操作的元素，事件名称，事件处理函数)。removeHandler(要操作的元素，事件名称，事件处理函数)。 var eventUtil = &#123; //添加句柄 addHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = handler; &#125; &#125;, //删除句柄 removeHandler: function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.attachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = null; &#125; &#125;&#125; 事件对象事件对象（event object）：在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。1.DOM中的事件对象（1）type属性 被触发的事件的类型（2）target属性 事件的目标（3）stopPropagation()方法 取消事件的进一步捕获或冒泡（4）preventDefault()方法 取消事件的默认行为2.IE中的事件对象event对象作为window对象的一个属性存在。（1）type属性 被触发的事件的类型（2）srcElement属性 事件的目标（3）cancelBubble属性 默认为false，设置成true可阻止事件冒泡（4）returnValue属性 默认值为ture，设置成false可取消时间的默认行为 由于IE不支持事件捕获， 更多属性方法，可查看W3C的事件：W3C的DOM事件参考手册 3.跨浏览器的事件对象var eventUtil = &#123; addHandler: function(element, type, handler) &#123; //忽略 &#125;, removeHandler: function(element, type, handler) &#123; //忽略 &#125;， getEvent: function(event) &#123; return event ? event : window.event; &#125;, getType: function(event) &#123; return event.type; &#125;, getElement: function(event) &#123; return event.target || event.srcElement; &#125;, preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;&#125; 事件类型一. DOM3级事件规定以下类型：UI事件：当用户与页面上的元素交互时触发焦点事件：当元素获得或失去焦点时触发鼠标事件：当用户通过鼠标在页面上执行操作时触发滚轮事件：当使用鼠标滚轮时触发文本事件：当在文档中输入文本时触发键盘事件：在用户通过键盘在页面上执行操作时触发合成事件：当为输入法编辑器输入字符时触发变动事件：当底层DOM结构发生变化时触发 二. UI事件UI事件：当用户与页面上的元素交互时触发1.load事件当页面完全加载后（包括所有图形、JavaScript文件、CSS文件等外部），就会触发window上面的load事件。window.onload = function() &#123; alert(\"loaded!\");&#125; 图像上面也可以触发load事件。在创建新的img元素时，要在指定src属性之前先指定事件。&lt;!--img元素也可以指定load事件，当图像成功下载执行load事件--&gt; &lt;!--如果图像路径有误，或者其他原因导致没有下载完成，则不会执行load事件--&gt; &lt;img src=\"smile.gif\" onload=\"alert('Image loaded.')\" /&gt; 在IE9+的浏览器中，script标签也能触发load事件。 2.unload事件unload事件在文档被完全卸载后触发，只要用户从一个页面切换到另一个页面，就会发生unload事件。利用这个事件最多的情况是清除引用，以避免内存泄露。 3.resize事件当浏览器窗口被调整到一个新的高度或宽度时，就会触发resize事件，这个事件在window上面触发。resize事件有可能被频繁执行，因此不适合在这个事件的处理程序中加入大计算量的代码。 4.scroll事件scroll事件是在window对象上发生的，但它实际表示的是页面中相应元素的变化。与resize事件类似，scroll事件也会在文档被滚动期间重复被触发。 三. 焦点事件焦点元素会在页面元素获得或失去焦点时触发。利用这些事件并于document.hasFocus()方法及document.activeElement属性配合，可以知晓用户在页面上的行踪。 常用焦点事件： 名称 触发方式 是否冒泡 blur 元素失去焦点时触发 否 focus 元素获得焦点时触发 否 focusin 元素获得焦点时触发 是 focusout 元素失去焦点时触发 是 四. 鼠标事件鼠标事件是Web开发中最常用的一类事件。1.列表 名称 触发方式 是否冒泡 click 单击鼠标左键或按下回车键 是 dblclick 双击鼠标左键 是 mousedown 按下任意鼠标按钮 是 mouseup 释放任意鼠标按键 是 mouseenter 鼠标指针从元素外部首次移动到元素范围内 否 mouseleave 鼠标指针从元素范围内移出 否 mouseout 鼠标指针位于一个元素上方，然后移入另一个元素 是 mouseover 鼠标指针从元素外部首次移动到元素范围内 是 mousemove 鼠标指针在元素内部移动 是 2.关联只有在同一个元素上相继触发mousedown和mouseup事件，才会触发click事件。只有触发两次click事件，才会触发一次dblclick事件。IE6 - 8中，双击时会跳过第二次mousedown和click事件.3.坐标位置鼠标事件发生的坐标位置保存在事件对象中。myDIv.addEventListener(\"click\", function(e)&#123; alert(e.clientX + \",\" + e.clientY); //在窗口中的位置 alert(e.pageX + \",\" + e.pageY); //在页面中的位置 alert(e.screenX + \",\" + e.screenY); //在屏幕中的位置&#125;, false); 参考资料：JS高级程序设计W3school HTML DOM参考手册","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"是Ajax啊","date":"2017-08-01T07:24:53.000Z","path":"2017/08/01/013/","text":"Ajax = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。Ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。Ajax技术的核心是XMLHttpRequest对象（简称XHR），运用XMLHttpRequest对象使后台与服务器进行数据交换，在重新加载页面的情况下取得新数据，再通过DOM操作将新数据插入到页面中。 XMLHttpRequest对象IE7+、Firefox、Chrome、Safari以及Opera都支持原生的XMLHttpRequest对象。在这些浏览器中可以使用XMLHttpRequest构造函数。var xhr = new XMLHttpRequest();在老版本的 Internet Explorer（IE5 和 IE6）使用 ActiveX 对象：variable=new ActiveXObject(“Microsoft.XMLHTTP”); XMLHttpRequest的属性收到响应后，响应的数据会自动填充XHR对象的属性：1.responseText属性:获得字符串形式的响应数据。2.responseXML属性:获得XML形式的响应数据。3.status属性:响应的HTTP状态4.statusText属性:HTTP状态的说明 xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304 5.readyState属性：存有XMLHttpRequest的状态，表示请求/响应过程的当前活动阶段。从0到4发生变化。&emsp;0: 未初始化。尚未调用open()方法&emsp;1: 启动。已经调用open()方法，但尚未调用send()方法&emsp;2: 发送。已经调用send()方法，但尚未接收到响应&emsp;3: 接收。已经接收到部分响应数据&emsp;4: 完成。已经接收到全部响应数据，而且已经可以在客户端使用了 xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200 //响应已就绪 6.onreadystatechange事件readyState的值每变化一次就触发一次onreadystatechange事件，必须在调用open()之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性。 XMLHttpRequest的方法1.open(method,url,async) 规定请求的类型、URL 以及是否异步处理请求。&emsp;method：请求的类型：GET 或 POST&emsp;url：请求的地址，文件在服务器上的位置&emsp;async：true（异步）或 false（同步）默认true 2.send(string) 将请求发送到服务器。send()方法接收一个参数即要作为请求主体发送的数据，如果不需要通过请求主体发送数据（比如GET请求)，则必须传入null（空的话有些浏览器不支持）。POST请求不给参数无意义，所以一般要接收一个string。 3.abort()方法 取消异步请求调用这个方法后，XHR对象会停止触发事件，而且也不再允许访问任何与响应有关的对象属性。将XMLHttpRequest 对象重置为 readyState 为 0 的状态。 4.setRequestHeader（）这个方法只有当 readyState 为 1 的时候才能调用，必须在调用open()方法之后且调用send()方法之前调用setRequestHeader()。然后在 send() 方法中规定您希望发送的数据。setRequestHeader(header,value) 向请求添加 HTTP 头。 5.getAllResponseHeaders()把 HTTP 响应头部作为未解析的字符串返回。如果 readyState 小于 3，这个方法返回 null。否则，它返回服务器发送的所有 HTTP 响应的头部。头部作为单个的字符串返回，一行一个头部。每行用换行符 “\\r\\n” 隔开。 6.getResponseHeader()返回指定的 HTTP 响应头部的值。其参数是要返回的 HTTP 响应头部的名称。可以使用任何大小写来制定这个头部名字，和响应头部的比较是不区分大小写的。该方法的返回值是指定的 HTTP 响应头部的值，如果没有接收到这个头部或者 readyState 小于 3 则为空字符串。如果接收到多个有指定名称的头部，这个头部的值被连接起来并返回，使用逗号和空格分隔开各个头部的值。 GET请求GET请求用于向服务器查询某些信息，可以将查询字符串参数追加到URL的末尾，以便将信息发送给服务器。查询字符串中每个参数的名称和值都必须使用encodeURIComponent()进行编码。 encodeURI() 函数可把字符串作为 URI 进行编码。返回URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换。该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&amp;=+$,#而如果 URI 组件中含有分隔符，比如 ? 和 #，则应当使用 encodeURIComponent() 方法分别对各组件进行编码。encodeURIComponent()：其他字符（;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的 POST请求POST请求的主体可以包含非常多的数据，而且格式不限。在open()方法的第一个参数的位置传入”POST”，就可以初始化一个POST请求。发送POST请求的第二部是向send()方法中传入某些数据。 我们可以将Content-Type头部信息设置为application/x-www-form-urlencoded模拟表单提交 跨源资源共享同源策略是对XHR的一个主要约束，它为通信设置了“相同的域，相同的端口，相同的协议”这一限制。默认情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。这种安全策略可以预防某些恶意行为，但是合理的跨域请求对开发某些浏览器应用程序至关重要。跨域资源共享Cross Origin Resource Sharing(CORS)定义了在必须访问跨域资源时，浏览器与服务器如何沟通。CORS的背后基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求响应是应该成功还是应该失败。 IE对CORS的实现：微软IE8引入了XDR(XDomainRequest)类型。这个对象与XHR类似，但能实现安全可靠的跨域通信。XDR对象的安全机制部分实现了W3C的CORS规范。XDR与XHR的不同之处：&emsp;cookie不会随请求发送也不会随响应返回。&emsp;只能设置请求头部信息中的Content-Type字段&emsp;不能访问响应头部信息&emsp;只支持GET和POST请求这些变化使CSRF(Cross-Site Request Forgery,跨站点请求伪造)和XSS(Cross-Site Scripting,跨站点脚本)的问题得到了缓解。 其他主流浏览器通过XMLHttpRequest对象实现了对CORS的原生支持。要请求位于另一个域中的资源，使用标准的XHR对象并在open()方法中传入绝对URL即可。跨域XHR对象可以访问status和statusText属性，而且支持同步请求。跨域XHR对象也有一些限制：&emsp;不能使用setRequestHeader()设置自定义头部&emsp;不能发送和接收cookie&emsp;调用getAllResponseHeaders()方法总会返回空字符串由于无论同源请求还是跨域请求都是用相同的接口，因此对于本地资源，最好使用相对URL，在访问远程资源时再使用绝对URL 其他跨域技术1.图像Ping图像Ping是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或者204响应。通过图像Ping浏览器得不到任何具体的数据，但通过侦听load和error事件，它能知道响应式什么时候接收到的。图像Ping最常用于跟踪用户点击页面或者动态官高曝光次数。图像Ping有两个主要的缺点，一时之能发送GET请求，二是无法访问服务器的响应文本。因此，它只能用于浏览器与服务器间的单向通信。 2.JSONPJSON with Padding，这里的 Padding 指的就是包裹在 JSON 外层的回调函数AJAX 无法跨域是受到“同源政策”的限制，但是带有src属性的标签（例如script、img、iframe）是不受该政策限制的，因此我们可以通过向页面中动态添加script标签来完成对跨域资源的访问，这也是 JSONP 方案最核心的原理。与图像Ping相比，它的优点是在于能够直接访问响应文本，支持在浏览器与服务器之间双向通信。但它是从其他域中加载代码执行，不能保证安全可靠。其次，确定JSONP请求是否失败并不容易。 JSON一种表示结构化数据的格式。JSON数据的书写格式：名称/值对中间用冒号隔开JSON的值类型：&emsp;简单值：字符串（双引号）、数值、布尔值（true false）和null，但不支持undefined&emsp;对象：一组无序的键值对儿。用{}&emsp;数组：一组有序的值的列表，可以通过数值索引来访问其中的值。用[] 与JS对象不同在于：JSON对象没有声明对象，其次没有末尾的分号，而且对象的属性必须加双引号。数组也没有变量和分号 JSON解析eval()函数可以解析、解释并返回JavaScript对象和数组。但eval()存在风险，尽量不要使用。不能原生支持JSON解析的浏览器，使用shim是最佳选择。 JSON对象有两个方法：stringify() 用于把JavaScript对象序列化为JSON字符串。默认输出的JSON字符串不包含任何空格字符或缩进。可以接收另外两个参数，第一个参数是过滤器（replacer），可以是数组也可以是函数。第二个参数是一个选项，表示是否在JSON字符串中保留缩进，如果这个参数是一个数值，它代表的是每个级别缩进的空格数。还可以给原生的对象定义toJSON()方法，返回其自身的JSON数据格式。 parse() 把JSON字符串解析为原生的JavaScript值。可以接受另一个参数，该参数是一个函数(reviver)，将在每个键值对上调用。","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"凉夜对词","date":"2017-07-31T15:32:15.000Z","path":"2017/07/31/012/","text":"婕叹“时光容易把人抛，红了樱桃，绿了芭蕉”，机智的我赶紧怼她“是流光容易把人抛”，她不服，我搬出原文《一剪梅·舟过吴江》 一片春愁待酒浇。江上舟摇，楼上帘招。秋娘渡与泰娘桥，风又飘飘，雨又萧萧。何日归家洗客袍？银字笙调，心字香烧。流光容易把人抛，红了樱桃，绿了芭蕉。 感叹传世名句后继续说起蒋捷另一首闻名于世的《虞美人·听雨》 少年听雨歌楼上，红烛昏罗帐。壮年听雨客舟中，江阔云低，断雁叫西风。而今听雨僧庐下，鬓已星星也。悲欢离合总无情，一任阶前点滴到天明。 婕说她越来越能体会少年壮年的那种变化，我开始说我喜欢的几首词。周邦彦的《解连环》 怨怀无托，嗟情人断绝，信音辽邈。纵妙手、能解连环，似风散雨收，雾轻云薄。燕子楼空，暗尘锁、一床弦索。想移根换叶，尽是旧时，手种红药。汀洲渐生杜若。料舟移岸曲，人在天角。谩记得、当日音书，把闲语闲言，待总烧却。水驿春回，望寄我、江南梅萼。拼今生，对花对酒，为伊泪落。 贺铸的《青玉案》 凌波不过横塘路，但目送、芳尘去。锦瑟华年谁与度？月桥花院，琐窗朱户，只有春知处。飞云冉冉蘅皋暮，彩笔新题断肠句。试问闲情都几许？一川烟草，满城风絮，梅子黄时雨。 我说我就是喜欢这种无端端又没什么大追求的小忧伤……就连辛弃疾我都更爱他的《摸鱼儿》。 更能消，几番风雨？匆匆春又归去。惜春长怕花开早，何况落红无数。春且住，见说道，天涯芳草无归路。怨春不语，算只有殷勤，画檐蛛网，镇日惹飞絮。长门事，准拟佳期又误，蛾眉曾有人妒。千金纵买相如赋，脉脉此情谁诉？君莫舞，君不见，玉环飞燕皆尘土。闲愁最苦，休去倚危栏，斜阳正在，烟柳断肠处。 那些壮阔激昂的家国情怀在课本里、在试卷上“体会”了太多，于我而言只有标准答案却没有共情，反而诗词里的儿女情长、伤春悲秋、感时悲逝的情绪最触动我。 夏夜难得的凉爽，有穿堂风过。心情太好，似乎有些难眠。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://wongyirong.github.io/tags/随笔/"}]},{"title":"JavaScript 错误 - Throw、Try 和 Catch","date":"2017-07-31T12:56:03.000Z","path":"2017/07/31/011/","text":"当 JavaScript 引擎执行 JavaScript 代码时，会发生各种错误。可能是语法错误，通常是程序员造成的编码错误或错别字。可能是拼写错误或语言中缺少的功能（可能由于浏览器差异）。可能是由于来自服务器或用户的错误输出而导致的错误。当然，也可能是由于许多其他不可预知的因素。 JavaScript 测试和捕捉try 语句允许我们定义在执行时进行错误测试的代码块。catch 语句允许我们定义当 try 代码块发生错误时，所执行的代码块。JavaScript 语句 try 和 catch 是成对出现的。语法try&#123;//在这里运行代码&#125;catch(err)&#123;//在这里处理错误&#125; Throw 语句throw 语句允许我们创建自定义错误。正确的技术术语是：创建或抛出异常（exception）。如果把 throw 与 try 和 catch 一起使用，那么您能够控制程序流，并生成自定义的错误消息。语法throw exception 异常可以是 JavaScript 字符串、数字、逻辑值或对象。","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"一个问题引出的正则表达式总结","date":"2017-07-27T00:44:02.000Z","path":"2017/07/27/010/","text":"早上我同学给我发了张截图，让我给她解释一下这段正则的含义。/^(?:([A-Za-z]+):)?(\\/&#123;0,3&#125;)([0-9.\\-A-Aa-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/ 刚开始看觉得好乱，但仔细看一下里面的语法都是熟悉的，我耐下心来，在笔记本画了下草图就感觉比较清晰了，这是一段匹配URL的正则表达式文本。理清后觉得很有必要做一些整理归纳工作，加强对正则表达式的语法记忆，也为自己建立一个参考手册。 regexp对象JavaScript内置对象RegExp实例化有两种方式：1.字面量var reg1 = /\\bbaidu\\b/g;2.构造函数：var reg2 = new RegExp(“\\bbaidu\\b”, “g”); 修饰符g:global 全文搜索 不加g默认找到第一个匹配就停止i:ignore case 忽略大小写 默认是大小写敏感m:multiple lines 多行搜索 元字符元字符是在正则表达式中有特殊含义的非字母字符1.有特殊含义的标点符号* + ? $ ^ . | \\ ( ) &#123; &#125; [ ] 2.直接量字符 字符 含义 字母及数字 自身 \\t 水平制表符 \\v 垂直制表符 \\n 换行符 \\r 回车符 \\0 空字符 \\f 换页符 3.字符类(1)将直接量字符单独放进方括号内就组成了字符类。一个字符类可以匹配它所包含的任意字符。(2)可以通过“^”符号定义否定字符类，匹配所有不在方括号内的字符。(3)还可以用“-”来表示范围a-z，类内部是可以连写的a-zA-Z。 4.预定义类 匹配常见的字符类 字符 等价类 含义 . [^\\r\\n] 除了回车符和换行符之外的所有字符 \\d [0-9] 数字字符 \\D [^0-9] 非数字字符 \\s [\\t\\n\\x0B\\f\\r] 空白符 \\S [^\\t\\n\\x0B\\f\\r] 非空白符 \\w [a-zA-Z_0-9] 单词字符（字母、数字、下划线） \\W [^a-zA-Z_0-9] 非单词字符 5.常用的边界匹配字符（锚字符） 字符 含义 ^ 匹配字符串的开头 $ 匹配字符串的结尾 \\b 单词边界 \\B 非单词边界 \\b 单词边界 (\\b并不匹配单词分隔字符中的任何一个，它只匹配一个位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\\w单词字符)另外：多行匹配时，加上/m后“^”才可以匹配一行的开始，$也是。 量词（重复） 字符 含义 {n,m} 匹配前一项至少n次，但不超过m次 {n,} 匹配前一项n次到多次 {n} 匹配前一项n次 ? 匹配前一项0次或1次，等价于{0,1} + 匹配前一项1次或者多次，等价于{1,} * 匹配前一项0次或多次，等价于{0,} 贪婪模式：匹配重复字符是尽可能多地匹配。默认。而非贪婪模式，只需要在量词后加上一个问号。 分组使用()分组，使量词作用于分组默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。1.使用|可以达到或的效果2.后向引用后向引用用于重复搜索前面某个分组匹配的文本。例如，\\1代表分组1匹配的文本。3.忽略分组不希望捕获某些分组，只需要在分组内加上?:就可以 零宽先行断言1.(?=p)零宽正向先行断言要求接下来的字符都与p匹配，但不能包括匹配p的那些字符。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re studying.时，它会匹配sing和study。2.(?!p)零宽负向先行断言要求接下来的字符不与p匹配 RegExp对象1.五个RegExp对象属性：global、multiline、ignoreCase、lastIndex、source(1)lastIndex：当前表达式匹配内容的最后一个字符的下一个位置(2)source：只读，正则表达式的文本字符串2.两个RegExp对象方法：(1)RegExpObject.test(string)test()方法用于检测一个字符串是否匹配某个模式.如果字符串 string 中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false。(2)RegExpObject.exec(string)exec()方法用于检索字符串中的正则表达式的匹配。如果没有匹配返回null,否则返回一个结果数组。返回的数组具有两个属性：index和input。&emsp;1)数组第一个元素包含的是与正则表达式相匹配的字符串&emsp;2)余下的元素是与子表达式相匹配的字符串&emsp;3)index声明匹配文本的其实字符在字符串的位置&emsp;4)input声明对stringObject的引用 用于模式匹配的String方法1.stringObject.search(regexp)search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。返回第一个匹配结果的index，查找不到返回-1search()方法不支持全局检索，它将忽略修饰符g，并且总是从字符串的开始进行检索。 2.stringObject.match(regexp)match()方法将检索字符串以找到一个或多个正则表达式的匹配。返回一个由匹配结果组成的数组，该数组的内容依赖于 regexp 是否设置了修饰符g。&emsp;(1)没有设置g，非全局检索它只执行一次匹配，如果没有找到任何的匹配文本，返回null否则将返回一个数组，数组第一项存放的是完整的匹配，剩下的存放的是与子表达式相匹配的字符串。返回的数组具有两个属性：index和input（非全局检索与exec返回的一模一样）&emsp;(2)设置了g，全局检索没有找到返回null，找到返回一个数组包含字符串中所有匹配结果。没有index属性和input属性 3.stringObject.split(regexp)split() 方法用于把一个字符串分割成字符串数组。返回一个字符串数组。 4.stringObject.replace(regexp, replacement)replace()方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。返回一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。replacement 可以是字符串，也可以是函数。&emsp;(1)如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。它说明从模式匹配得到的字符串将用于替换。&emsp;(2)replacement是函数的情况，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是index，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。 最后让我们再回到最开始的问题，看着这张可视化工具生成的图，再次回忆一下语法。是不是很容易理解了。 参考资料：《JaveScript权威指南》《正则表达式30分钟入门教程》《微软的正则表达式教程》在线网站：正则表达式可视化工具正则表达式学习正则表达式练习 有没有发现我的MD语法进步了呢……","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"使用node.js和mongoDB建站","date":"2017-07-26T00:44:02.000Z","path":"2017/07/26/009/","text":"这两天跟着慕课网的一个视频学习node.js和MongoDB建站，第一次使用MongoDB，看着教程学习了一下基本使用。 git将本地项目上传到github(git status)，首先在github上创建一个Git仓库 git init git add . git commit -m &quot;first commit&quot; git remote add origin https://github.com/wongyirong/iMooc.git git push -u origin master 另外:由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库有了内容之后，下次使用git push origin master还有一个问题，当时我在github上创建仓库的时候勾选了Initialize this repository with a README，在git push的时候报错，我当时为了解决问题，强制推送git push -f origin master，总结的时候又查了一下发现可以先将远程pull下来再push git pull -r origin master MongoDBmongoDB手动启动服务：mongod –dbpath=D:\\Develop\\MongoDB\\Server\\3.4\\data\\db注册为windows服务：mongod.exe –logpath “D:\\Develop\\MongoDB\\Server\\3.4\\data\\log\\mongodb.log” –logappend –dbpath “D:\\Develop\\MongoDB\\Server\\3.4\\data\\db” –serviceName “MongoDB” –install安装未成功，解决办法：找到cmd.exe，右键以管理员身份运行，然后再执行上述注册服务的命令。 nodenpm install -g nn latest","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"从输入URL到页面加载完成到底发生了什么？","date":"2017-07-19T01:22:09.000Z","path":"2017/07/19/008/","text":"&emsp;&emsp;这应该是我开始学习前端之后看到的次数最多的一道面试题目，也是我最怕的一道题目了。计算机网络和硬件方面我还是个文盲，我对软件一直更感兴趣一点，对网络和硬件就比较心虚，寒暑假回家大爷大妈让我修电脑的时候，我只能无奈地一再强调自己是学软件的。为了更好地 为人民服务 学习前端，我准备从头到尾理清这道题，借此完成计算网络的攻坚克难战，顺便准备技术交流的素材。&emsp;&emsp;在我最开始的意识里，这个过程应该是在浏览器地址栏输入URL之后信息被送到了某处，然后获得回复，内容按照一定格式(前端要做的工作)展示在Web页面上。而事实上在电脑显示器后面在这短短的时间(网速好的话)内有太多看不到的过程发生了。 1.输入URL后浏览器做了什么我们先来理解一下URL是什么，它为我们做了什么 (1)URL Uniform Resource Locator 统一资源定位符URI（Uniform Resource Identifier) 统一资源标识符URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置），URL是URI的子集。URL的一般格式为(带方括号[]的为可选项)：protocol :// hostname[:port] / path / [;parameters][?query]#fragment URL由三部分组成：协议类型，主机名和路径及文件名。通过URL可以指定的主要有以下几种：http、ftp、gopher、telnet、file等。 1、protocol（协议）：指定使用的传输协议 file 资源是本地计算机上的文件。格式file:// ftp 通过 FTP访问资源。格式 FTP:// http 通过 HTTP 访问该资源。格式 HTTP:// https 通过安全的 HTTPS 访问该资源。格式 HTTPS:// mailto 资源为电子邮件地址，通过 SMTP 访问。格式 mailto: 2、hostname（主机名）：是指存放资源的服务器的域名系统 (DNS) 主机名或 IP 地址。有时，在主机名前也可以包含连接到服务器所需的用户名和密码（格式：username:password）。 3、port（端口号）：整数，可选，省略时使用方案的默认端口，各种传输协议都有默认的端口号，如http的默认端口为80。如果输入时省略，则使用默认端口号。有时候出于安全或其他考虑，可以在服务器上对端口进行重定义，即采用非标准端口号，此时，URL中就不能省略端口号这一项。 4、path（路径）：由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。 5、;parameters（参数）：这是用于指定特殊参数的可选项。 6、?query(查询)：可选，用于传递参数，可有多个参数，用“&amp;”符号隔开，每个参数的名和值用“=”符号隔开。 7、fragment，代表了资源内的一个位置。 在 URI 的末尾通过 hash mark（#）作为 fragment 的开头，其中#不属于 fragment 的值。1.#有别于?。?后面的查询字符串会被网络请求带上服务器，而 fragment 不会被发送的服务器；2.fragment 的改变不会触发浏览器刷新页面，但是会生成浏览历史（对IE 6和IE 7不成立）；3.fragment 会被浏览器根据文件媒体类型（MIME type）进行对应的处理；4.Google 的搜索引擎会忽略 # 及其后面的字符串。如果希望Ajax生成的内容被浏览引擎读取，可以使用”#!”5.JS中可以通过window.location.hash来读取或改变＃的值 (2)负责域名解析的DNS服务 Domain Name System 应用层DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务URL和DNS协议为我们标识了资源的地点，让我们知道去哪里请求需要的资源。 2.在传输过程中发生了什么Web采用HTTP协议作为规范，完成从客户端到服务器端的通信。HTTP协议 Hyper Text Transfer Protocol 超文本传输协议 应用层HTTP协议基于TCP/IP协议族进行网络通信。其中包括： (1)负责传输的IP协议 Internet Protocol 网际协议 网络层MAC地址 Media Acess Control Address使用ARP协议进行通信 (2)确保可靠性的TCP协议 Transmission Control Protocol 传输控制协议 传输层为什么说它是确保可靠性的呢，TCP协议为了准确无误的将数据送达目标处采用了三次握手three-way-handshaking策略TCP 协议的三次握手 – 用以确认数据传输正确，会重试到完整地完成为止。 TCP/IP传输流：作为发送端的客户端在应用层（HTTP协议）发出HTTP请求。为了传输方便在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在格格报文上打上标记序号及端口号后转发给网络层。在网络层（IP协议）增加作为通讯目的地的MAC地址后转发给数据链路层。接收端的服务器在数据链路层接收到数据，发送到网络层传输层一直到应用层。这时候接收端的服务器才真正收到了了客户端的HTTP请求。 HTTP请求由三部分组成，分别是：请求行、首部字段、报文主体请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。 请求方法有多种： 请求方法 说明 GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据 HEAD 请求获取由Request-URI所标识的资源的响应消息报头 PUT 请求服务器存储一个资源，并用Request-URI作为其标识 DELETE 请求服务器删除Request-URI所标识的资源 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求 在html页面中输入URL、访问超链接、form提交（当然也可以设置method为POST）等都是GET请求方法，比如本题“从输入URL到页面加载完成到底发生了什么？” GET和POST对比：GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。GET是幂等的POST：一般用于修改服务器上的资源，对所发送的信息没有限制。GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。然而，在以下情况中，请使用 POST 请求：无法使用缓存文件（更新服务器上的文件或数据库）；向服务器发送大量数据（POST 没有数据量限制）；发送包含未知字符的用户输入时，POST比GET更稳定也更可靠。 HTTP响应也是由三个部分组成，分别是：状态行、首部字段、报文主体状态行格式：HTTP-Version Status-Code Reason-Phrase CRLF其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。比如HTTP/1.1 200 OK 响应状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 响应状态代码 状态描述 说明 1xx 指示信息 表示请求已接收，继续处理 2xx 成功 表示请求已被成功接收、理解、接受 3xx 重定向 要完成请求必须进行更进一步的操作 4xx 客户端错误 请求有语法错误或请求无法实现 5xx 服务器端错误 服务器未能实现合法的请求 常见状态代码、状态描述、说明： 常见状态代码 状态描述 说明 200 OK 客户端请求成功 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized 请求未经授权，必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务 404 Not Found 请求资源不存在，eg：输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误 503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 从100到199范围的HTTP状态码是信息报告码。基于各种原因考虑，大多数情况下我们是很少看见这些代码的。首先，如果一个浏览器尝试访问一个网站，而网站返回这些代码时，它们往往都不会显示在屏幕上。它们只是浏览器使引用的内部码。另外，这些代码不常见的另外一个原因是起初HTTP标准不允许使用这一范围的状态码。就其本身而言，它们也一直没有被广泛地使用。 HTTP/1.1首部字段 通用首部字段 首部字段名 说明 Cache-Control 控制缓存的行为 Connection 逐跳首部、连接的管理 Date 创建报文的日期时间 Pragma 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知 请求首部字段 首部字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言（自然语言） Authorization Web认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在服务器 if-Match 比较实体标记（ETag） if-Modified-Since 比较资源的更新时间 if-None-Match 比较实体标记（与if-Match相反） if-Range 资源未更新时发送实体Byte的范围请求 if-Unmodified-Since 比较资源的更新时间（与if-Modified-Since相反） Max-Forwards 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中URI的原始获取方法 TE 传输编码的优先级 User-Agent HTTP客户端程序的信息 响应首部字段 首部字段名 说明 Accept-Ranges 是否接受字节范围请求 Age 推算资源创建经过时间 ETag 资源的匹配信息 Location 令客户端重定向至指定的URI Proxy-Authenticate 代理服务器对客户端的认证信息 Reter-After 对再次发起请求的时机要求 Server HTTP服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 实体首部字段 首部字段名 说明 Allow 资源可支持的HTTP方法 Content-Encoding 实体主体的适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小（单位：字节） Content-Location 替代对应资源的URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期的日期时间 Last-Modified 资源的最后修改日期时间 在这里同学问我Expires是缓存还是Cookie的失效时间。Expires是将资源失效的日期告知客户端。源服务器不希望缓存服务器对资源缓存时会将Expires字段写入与首部字段Date相同的时间值，就像当时看到的百度的示例。但当同时存在Cache-control的max-age会优先处理max-age指令，忽略掉Expires。max-age代表资源保存为缓存的最长时间。 响应的结果也同样利用TCP/IP通信协议向客户端回传。 这里我的同学帮我补充了一点：关于cookie的状态管理HTTP是无状态协议，他不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。Cookie会根据从服务器端发送的响应的报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后的到之前的状态信息。 还有一种服务端的机制——Session。Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Redis之类的来放 Session。区别：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式 3.请求到数据后浏览器做了什么当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：解析 —— HTML，CSS，JS渲染 —— 构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制（1）首先，浏览器渲染引擎从网络层取得请求的资源，一般以8kB大小分块传输。（2）HTML解析器对HTML文档进行解析，生成解析树。解析树是以DOM（文档对象模型 Document Object Model）元素以及属性为节点的树。它是HTML文档的对象表示，同时也是HTML元素面向外部(如Javascript)的接口。树的根部是”Document”对象。整个DOM和HTML文档几乎是一对一的关系。（3）遇到css标签解析CSS生成CSS规则树（4）浏览器通过遍历CSS规则树和DOM节点树创建一个渲染树（Render Tree）（5）页面布局和绘制 注意：渲染结束后，JavaScript下载后JS操作修改DOM、修改样式都会造成渲染树的重新布局和重绘。只要修改DOM或修改了元素的形状或大小，就会触发Reflow，单纯修改元素的颜色只需Repaint一下。 参考资料：《图解http》腾讯IMWeb知乎专栏what-happens-when6 Things You Should Know About Fragment URLs","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"爱你就像爱生命","date":"2017-07-16T11:48:49.000Z","path":"2017/07/16/007/","text":"你能建立良好的项目和解决问题，这才是最重要的，而你如何解决它们（所使用的工具）已经并将永远改变。If you can build good projects and solve problems then that’s all that matters, how you solve them (the tools) has and will always change. 珍惜生命 远离IE6","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"岁月轻狂","date":"2017-07-16T07:49:25.000Z","path":"2017/07/16/006/","text":"&emsp;&emsp;昨天整理了豆列，全是自己想买的东西。今天因为凯尔经的秘密打开豆瓣电影，发现大学四年真的看了好多动画电影，那时候雪姐和大静还有伢伢只要有好的片子就不会放过，最神奇的是雪姐总能找到好多久远的但是好看的片子，尤其是认识李晓龙之后。&emsp;&emsp;我还能清晰的记起从青科吃完饭走回去时风的温度、天空的颜色、青科电台放的那首《岁月轻狂》。看向我们宿舍那一块，建筑高高低低，礼堂的屋顶尖尖的，宿舍晾晒的衣服迎风飘扬着。青科操场那一片天空格外的开阔，颜色总是那么多彩，望出去能看到西院操场上的人和远处海边的高楼。在那条路上有一株合欢树，我和伢伢专门去看过它的花。快到东院后门那里有一整墙如瀑的爬山虎，四年来一年比一年生机勃勃。而那面高高的围墙，好像从来没看到过头。从夏天开始一直到初秋，后门有一块地会有花门一样的玫瑰，间或几只钻出铁网对路人say hello。进了后门通往二综路两侧是山樱花和榆叶李，开花的时候满树满树的欣喜，不开花的时候总是映衬得天空特别蓝。树与树之间的空隙里可以看到东院操场，青岛真的是气候宜人，而那里又是风景绝佳，离开时最舍不得的就是那里，四年来在哪里发生过太多故事，欢乐悲伤平静愤怒，见证了我的一切，又陪伴了我的四年，我总想回去看看，什么都不做，就想再走几圈看看远山看看日落。&emsp;&emsp;回忆着竟然想起，大一的冬天，想给强哥织条围巾，寒夜里站在大门口跟卖毛线的大姐学，零下好几度的天气手都冻僵了。可是到最后也没有织好看，后来暑假在家想重新织条，却怎么都想不起怎么起头了。 2016-08-15 18:57:36","tags":[{"name":"随笔","slug":"随笔","permalink":"https://wongyirong.github.io/tags/随笔/"}]},{"title":"时间并不会把每个人带到同一个位置","date":"2017-07-16T04:47:31.000Z","path":"2017/07/16/005/","text":"&emsp;&emsp;我姐上小学的时候，数学总是不及格，我比她小两级，每次我都笑话她，她就会说：我们数学难，等你上高年级你也考不及格。可是后来我上三年级四年级五年级六年级，成绩一直很好。时间并不会把每个人带到同样一个位置，决定位置高低的还是你自己啊。&emsp;&emsp;很多人喜欢在劝我的时候拿更差的人来做对比，这让我很不理解。一是我并不想和别人比，明明标准在那里，而我没达到而已。二是我只是陈述事实，不是消极难过，本就是不需要劝。&emsp;&emsp;每次这种时候我就会变成两个人，一个人耐心给她们解释I’m fine ，另一人在想我要这么多“朋友”干什么。事事嘘寒问暖有一个我妈，就够了。劝人的时候不要说一些违心的话，夸人的时候同样。既然是你的立场你就要时刻坚持，如果觉得说出来会伤害到别人，可以选择不说。我更喜欢耿直的朋友，他们让我觉得舒服。只是想法不同并不是要与你为敌，我们每个人都是有着独立思想的个体，我们成为朋友不过只是互相接纳互相包容的结果。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://wongyirong.github.io/tags/随笔/"}]},{"title":"那些话儿","date":"2017-07-15T13:21:16.000Z","path":"2017/07/15/004/","text":"&emsp;&emsp;我记性不好，又总是希望能记住生活中发生的听到的看到的所有事情，为此这些年一直坚持使用QQ空间留言板，用到都有人开始嘲笑我才慢慢转移阵地。后来收了workflow和印象笔记后，我开始每天和采蘑菇的小女孩似的，把喜欢的句子说过的话想珍藏的一切复制了往印象笔记里粘，还会时不时打开印象笔记一本满足的清点满筐的“蘑菇”。&emsp;&emsp;话特别多想法特别多的我在别人眼里越来越奇怪了，而我不能理解的人和事情也越来越多，篮子里采了那么多蘑菇却只能自己偶尔的拿出来看看，晒不到太阳不可避免的开始发霉了。人总是期待被理解，被认可，孤独也不过是宁为玉碎不为瓦全。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://wongyirong.github.io/tags/随笔/"}]},{"title":"我的博客简介","date":"2017-07-15T10:28:20.000Z","path":"2017/07/15/003/","text":"&emsp;&emsp;之前一直想建一个自己的网站，本来打算的是买一个阿里云或者腾讯云的服务器，自己用node+vue+MongoDB前后端分离一整套做出来，但以我现在的能力又任重道远。前几日发现了GitPages，就打算利用Pages做点页面展示。&emsp;&emsp;昨天听Litten的直播课，听的时候一直感叹他的优秀，专门记住了名字。今天按原计划建我的博客，对比了一些流行的静态博客框架后决定采用hexo，主要是看到hexo是node.js写的，感觉有亲切感。&emsp;&emsp;找了个教程看着做，在选主题的时候看到Litten的名字，简直闪闪发光！啊，人生何处不相逢。&emsp;&emsp;过程中还是遇到很多问题，午饭后对着Litten的github和hexo的官方文档才搞清楚。晚饭后本来要做编程题，可是看Litten的博客有个相册功能，我又很想试试。","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"陌生人啊感谢你的好意","date":"2017-07-15T08:36:20.000Z","path":"2017/07/15/002/","text":"&emsp;&emsp;昨天在网上看IMWeb的笔试直播课，我才发现愚蠢而固步自封的我离前端工程师的路太远了。而留给我赶路的时间却不多，我知道自己必须停下来，记下这些感动，记住这些的来之不易的相逢。我一直后悔很多过去的事情，而过去的时光不再，当下也是未来会后悔的时刻啊。&emsp;&emsp;人生有很多弯路，明明别人一早就告诉你了，可你没走过你总不肯相信那真的是条弯路。也许不是现在我可能不会报这个班，如果不是现在我可能并不能恰好的体会这些，让我后悔的过去、走过的弯路其实都是最好的安排。&emsp;&emsp;昨天更大的收获是认识了一个真正优秀的前端工程师，我确信我爱自己的选择，但我真的离我想成为的人有很远的距离。陌生人啊，感谢你的好意你的真心，能在这一刻幡然醒悟，睁开双眼看世界，我应该感激。我的人生真是幸运，那些驼背走在路上唉声叹气的人，那些碌碌无为浑浑度日的人，他们都不曾遇到我这样的好运气。真感激，我是我，我遇到过这么多好人。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://wongyirong.github.io/tags/随笔/"}]},{"title":"裙角飞扬的日子","date":"2016-08-10T03:24:23.000Z","path":"2016/08/10/001/","text":"我的wordpress的一些记录 明明快好了，昨晚一直不困，就一直熬到两点多才睡，早上实在是醒不来，头也痛，鼻塞更甚，咳嗽了一上午。中午睡醒竟有种熟悉的发烧的感觉，说不来的难受，在床上又呆了一个小时才好一些。 啊，我开通了CSDN博客，哈哈哈2016-08-28 19:09:59 病来如山倒 20160825有咽炎，扁桃体炎，昨天和前几天有微微的嗓子痛，没在意，昨天晚上洗冷水，洗完就鼻塞难受，早上起来咽痛，轻微，清涕。20160826白天喝了很多红糖可乐姜茶，晚上咽干严重，鼻塞更甚。今天早上买了云南白药《风寒感冒颗粒》，效果比较明显，咽干好一些，鼻塞，流涕好一些，头痛也好了些，但是还是打喷嚏。明天再看效果。2016-08-25 08:59:51 记录 放在回忆里，不如忘记。醒来收到微信速来宝的消息，领了发现是之前东野兴冲冲给我预定的大冰的新作，我不知该说啥，自从当年亲眼见过他，我竟然感觉自己看穿了他，对他越来越不屑。东野要送我我也不知道如何拒绝，拿到翻开的兴趣都没有，希望东野能见谅，当然是建立在她不知道的前提下。我换了新号码竟然还能收到，要是没收到就好了。2016-08-16 14:44:02 你的善良必须有点锋芒–不然就等于零。2016-08-11 09:19:11 翻出14年7月到9月的一些记录，发现也许你做的对。我走过很多弯路，我做过很多错事，如果只是记忆模糊就当它不存在这是多么自欺欺人，问题是我明明走过不止一个弯路，仍不知悔改。2016-08-10 16:34:05 明白那么多道理，仍然不想好好地过这一生。 最近有些压抑，人生的路要走向何方，我到底怎么了，我以后要怎么办，很多问题想不清，想梳理明白，各大社交网站越玩越寂寞，想静静的在自己的世界想清楚。2016-08-10 11:24:23 我的wordpress纪念","tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://wongyirong.github.io/tags/碎碎念/"}]}]