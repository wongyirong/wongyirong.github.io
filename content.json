[{"title":"性能优化","date":"2017-10-05T07:49:25.000Z","path":"2017/10/05/034/","text":"网络性能优化，加快访问速度，浏览器并行加载数量，怎样实现原生JS异步载入，CDN加速的原理，如何将不同静态资源发布到多个域名服务器上，发布后这些静态字段的url路径改怎么批量改写，用什么工具进行项目打包，css打包后的相对路径怎么转换为绝对路径，用什么工具进行项目模块依赖管理，怎么进行cookie优化","tags":[{"name":"笔试面试","slug":"笔试面试","permalink":"https://wongyirong.github.io/tags/笔试面试/"}]},{"title":"Ajax和跨域问题整理","date":"2017-10-04T01:50:38.000Z","path":"2017/10/04/033/","text":"本文将对面试问题里的Ajax和跨域部分进行整理 Ajax1、什么是Ajax（请谈一下你对Ajax的认识） Ajax是“Asynchronous JavaScript and XML”的简写，异步的JavaScript和XML，它能够在不刷新网页的情况下从服务器取得数据，Ajax的核心的是XMLHttpRequest对象，Ajax的原理简单来说通过XMLHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。 2、Ajax实现步骤 1.创建xhr对象，创建的时候考虑浏览器兼容性，封装一个createXHR()函数。检测原生XHR对象是否存在，如果存在返回它的新实例new XMLHttpRequest()。如果不存在，则检测ActiveX对象，因为IE7以下的XHR对象是通过MSXML库中的一个ActiveX对象实现的。如果都不存在就抛出一个错误。 var xhr = createXHR(); 2.为XHR对象添加事件处理程序，XHR对象用于Ajax时open()方法的async参数必须设置为true，需要指定在响应处于onreadystatechange事件中就绪状态时执行的函数。做两个if判断，判断readyState是否等于4，即响应完毕，status是否是2开头或者304，即一切正常。 xhr.onreadystatechange = function () &#123;//先检测XHR对象的readyState属性，该属性为4的阶段表示所有数据都已经就绪 if(xhr.readyState == 4) &#123; //再检测收到的响应的status属性，以确认响应是否已经成功返回。http状态码2开头表示请求已被接收、理解并接受，304表示请求的资源没有被修改可以直接使用浏览器中缓存的版本，响应也是有效的 if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) ||xhr.status == 304) &#123; alert(xhr.responseText); &#125;else &#123; alert(\"Request was unsucessful: \" + xhr.status); &#125; &#125;&#125;; 3.调用open()启动一个请求。 xhr.open(http请求方式get,post,相对执行代码的当前页面的url,设置异步或同步方式交互true,false); 4.向服务器端发送请求数据。 xhr.send(null); send()方法接收一个参数，即要作为请求主体发送的数据，不需要发送数据必须传入null 5.接收响应数据。在接收到响应之前可以调用abort()方法来取消异步请求 xhr.abort(); 3、GET和POST区别 1.GET请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给WEB服务器。2.先是”GET方式提交的数据最多只能是1024字节”，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。3.GET方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。在某种情况下，GET方式会带来严重的安全问题。而POST方式相对来说就可以避免这些问题。 4、为什么要用Ajax（优缺点）Ajax优点： 通过异步模式，提升了用户体验 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用 Ajax引擎在客户端运行，承担了一部分本来由服务器承担的工作，从而减少了大用户量下的服务器负载。 Ajax缺点： 1.Ajax不支持浏览器back按钮，即破坏了浏览器后退机制。2.安全问题 AJAX暴露了与服务器交互的细节。3.对搜索引擎的支持比较弱4.破坏了程序的异常机制。5.不容易调试 5、Ajax应用和传统Web应用有什么不同 在传统的Javascript编程中，如果想得到服务器端数据库或文件上的信息，或者发送客户端信息到服务器，需要建立一个HTML form然后GET或者POST数据到服务器端。用户需要点击“Submit”按钮来发送或者接受数据信息，然后等待服务器响应请求，页面重新加载。因为服务器每次都会返回一个新的页面，所以传统的web应用有可能很慢而且用户交互不友好。使用Ajax技术，就可以使Javascript通过XMLHttpRequest对象直接与服务器进行交互。通过HTTP Request，web页面可以发送请求到服务器并且接收服务器返回的信息(不用重新加载页面)，展示给用户的还是一个页面，用户感觉不到页面刷新，也看不到到Javascript后台进行的发送请求和接受响应。 前端面试题——手写实现ajaxXMLHttpRequest对象const xhr = new XMLHttpRequest() 实例化后，我们就可以通过 xhr 来发起一个请求// xhr 具有一个 open 方法，这个方法的作用类似于初始化，并不会发起真正的请求// open 方法具有 5 个参数，但是常用的是前 3 个// method： 请求方式 —— get / post// url：请求的地址// async：是否异步请求，默认为 true（异步）xhr.open(method, url, async)// send 方法发送请求，并接受一个可选参数// 当请求方式为 post 时，可以将请求体的参数传入// 当请求方式为 get 时，可以不传或传入 null// 不管是 get 还是 post，参数都需要通过 encodeURIComponent 编码后拼接xhr.send(data) 在通过send方法发送请求后，xhr对象在收到响应数据时会自动填充到其对应的属性中，xhr 具有以下常用属性： responseText： 请求返回的数据内容responseXML： 如果响应内容是”text/xml””application/xml”，这个属性将保存响应数据的 XML DOM文档status： 响应的HTTP状态，如 200 304 404 等statusText： HTTP状态说明readyStatus： 请求/响应过程的当前活动阶段timeout： 设置请求超时时间 readyStatus的值会随着请求各阶段的变化而改变，其一共有 5 个值： xhr.readyStatus==0 尚未调用 open 方法xhr.readyStatus==1 已调用 open 但还未发送请求（未调用 send） xhr.readyStatus==2 已发送请求（已调用 send）xhr.readyStatus==3 已接收到请求返回的数据xhr.readyStatus==4 请求已完成 当readyStatus的状态发生改变时，会触发 xhr 的事件onreadystatechange，于是我们就可以在这个方法中，对接收到的数据进行处理xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyStatus === 4) &#123; // HTTP 状态在 200-300 之间表示请求成功 // HTTP 状态为 304 表示请求内容未发生改变，可直接从缓存中读取 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; console.log('请求成功', xhr.responseText) &#125; &#125;&#125; 当网络不佳时，我们需要给请求设置一个超时时间// 超时时间单位为毫秒xhr.timeout = 1000// 当请求超时时，会触发 ontimeout 方法xhr.ontimeout = () =&gt; console.log('请求超时') 以上就是 XMLHttpRequest 对象的基础内容，它还有很多其他的属性和时间，如onerror onabort onload等等 以下是一个极简 ajax 请求方法，该 ajax 方法通过 Promise 方式实现回调function ajax (options) &#123; let url = options.url const method = options.method.toLocaleLowerCase() || 'get' const async = options.async != false // default is true const data = options.data const xhr = new XMLHttpRequest() if (options.timeout &amp;&amp; options.timeout &gt; 0) &#123; xhr.timeout = options.timeout &#125; return new Promise ( (resolve, reject) =&gt; &#123; xhr.ontimeout = () =&gt; reject &amp;&amp; reject('请求超时') xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState == 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; resolve &amp;&amp; resolve(xhr.responseText) &#125; else &#123; reject &amp;&amp; reject() &#125; &#125; &#125; xhr.onerror = err =&gt; reject &amp;&amp; reject(err) let paramArr = [] let encodeData if (data instanceof Object) &#123; for (let key in data) &#123; // 参数拼接需要通过 encodeURIComponent 进行编码 paramArr.push( encodeURIComponent(key) + '=' + encodeURIComponent(data[key]) ) &#125; encodeData = paramArr.join('&amp;') &#125; if (method === 'get') &#123; // 检测 url 中是否已存在 ? 及其位置 const index = url.indexOf('?') if (index === -1) url += '?' else if (index !== url.length -1) url += '&amp;' // 拼接 url url += encodeData &#125; xhr.open(method, url, async) if (method === 'get') xhr.send(null) else &#123; // post 方式需要设置请求头 xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded;charset=UTF-8') xhr.send(encodeData) &#125; &#125; ) &#125; 使用方式ajax(&#123; url: 'your request url', method: 'get', async: true, timeout: 1000, data: &#123; test: 1, aaa: 2 &#125;&#125;).then( res =&gt; console.log('请求成功: ' + res), err =&gt; console.log('请求失败: ' + err)) 跨域1.跨域： 同源策略是由Netscape提出的著名安全策略，是浏览器最核心、基本的安全功能，浏览器的同源策略可以限制对跨域资源的访问。所谓的同源就是指协议、域名、端口相同。以上三部分只要有一个不同，浏览器就会认为是跨域资源访问。 2.哪些操作会有跨域限制？ 比如用Ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。在浏览器中，script、img、iframe、link等带src属性标签都可以加载跨域资源，而不受同源限制，但浏览器限制了JavaScript的权限使其不能读、写加载的内容。另外同源策略只对网页的HTML文档做了限制，对加载的其他静态资源如JS、css、图片等仍然认为属于同源 3.没有跨域的限制会怎么样？ 安全性问题，比如一个恶意网站的页面通过iframe嵌入了银行的登录页面（二者不同源），如果没有同源限制，恶意网页上的javascript脚本就可以在用户登录银行的时候获取用户名和密码。 跨域解决方案关于跨域大概可以分为 iframe 的跨域和纯粹的跨全域请求。 三种跨全域的方法：1. JSONP Web 页面上调用js文件不受浏览器同源策略的影响，所以通过Script标签可以进行跨域的请求： 1.首先前端先设置好回调函数，并将其作为 url 的参数。 2.服务端接收到请求后，通过该参数获得回调函数名，并将数据放在参数中将其返回 3.收到结果后因为是script标签，所以浏览器会当做是脚本进行运行，从而达到跨域获取数据的目的。 优点： 它不像XMLHttpRequest 对象实现 Ajax 请求那样受到同源策略的限制兼容性很好，在古老的浏览器也能很好的运行不需要 XMLHttpRequest 或 ActiveX 的支持；并且在请求完毕后可以通过调用 callback 的方式回传结果。 缺点： 它支持 GET 请求而不支持 POST 等其它类行的 HTTP 请求。它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面或 iframe 之间进行数据通信的问题 2. 跨域资源共享CORS CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了ajax只能同源使用的限制。CORS需要浏览器和服务器同时支持才可以生效，对于开发者来说，CORS通信与同源的ajax通信没有差别，代码完全一样。浏览器一旦发现ajax请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 &lt;script&gt;const xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; alert(xhr.responseText); &#125; &#125;&#125;;xhr.open('GET', 'http://127.0.0.1:3000', true);xhr.send(null);&lt;/script&gt; 服务端收到请求后的处理:require('http').createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; 'Access-Control-Allow-Origin': 'http://localhost:8080' &#125;); res.end('这是你要的数据：3000');&#125;).listen(3000, '127.0.0.1'); 关键是在于设置相应头中的 Access-Control-Allow-Origin，该值要与请求头中 Origin 一致才能生效，否则将跨域失败。CORS 的优缺点： 使用简单方便，更为安全支持 POST 请求方式CORS 是一种新型的跨域问题的解决方案，存在兼容问题，仅支持 IE 10 以上 CORS详解 3. Server Proxy服务器代理 服务器代理，顾名思义，当你需要有跨域的请求操作时发送请求给后端，让后端帮你代为请求，然后最后将获取的结果发送给你。 四种通过 iframe 跨域与其它页面通信的方式。 4. iframe+location.hash: 改变 hash 值不会导致页面刷新，所以可以利用 hash 值来进行数据的传递，当然数据量是有限的缺点： 数据直接暴露在了url中数据容量和类型都有限等等 5. iframe+window.name： window.name（一般在 js代码里出现）的值不是一个普通的全局变量，而是当前窗口的名字，这里要注意的是每个 iframe 都有包裹它的 window，而这个 window 是top window 的子窗口，而它自然也有 window.name 的属性，window.name 属性的神奇之处在于 name 值在不同的页面（甚至不同域名）加载后依旧存在（如果没修改则值不会变化），并且可以支持非常长的 name 值（2MB）。 6. iframe+postMessage: postMessage 是 HTML5 新增加的一项功能，跨文档消息传输(Cross Document Messaging)，目前：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+和 Safari 4.0+ 都支持这项功能 7. ifram+document.domain： 对于主域相同而子域不同的情况下，可以通过设置 document.domain 的办法来解决，具体做法是可以在 http://www.example.com/a.html 和 http://sub.example.com/b.html 两个文件分别加上 document.domain = “a.com”；然后通过 a.html文件创建一个iframe，去控制iframe的window，从而进行交互，当然这种方法只能解决主域相同而二级域名不同的情况 还有诸如Fetch、Node、Webpack、proxyTable等方式。 JSONP原理 JSONP (JSON with Padding)是一个简单高效的跨域方式，HTML中的script标签可以加载并执行其他域的JavaScript，于是我们可以通过script标记来动态加载其他域的资源。例如我要从域A的页面pageA加载域B的数据，那么在域B的页面pageB中我以JavaScript的形式声明pageA 需要的数据，然后在pageA中用script标签把pageB加载进来，那么pageB中的脚本就会得以执行。JSONP在此基础上加入了回调函数，pageB加载完之后会执行pageA中定义的函数，所需要的数据会以参数的形式传递给该函数。JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。 封装一个jsonp//JavaScript权威指南P507function getJSONP(url, callback) &#123; var cbnum = \"cb\" + getJSONP.counter++; var cbname = \"getJSONP.\" + cbnum; if(url.indexOf(\"?\") === -1) &#123; url += \"?jsonp=\" + cbname; &#125; else &#123; url += \"&amp;jsonp=\" + cbname; &#125; var script = document.createElement(\"script\"); getJSONP[cbnum] = function (response) &#123; try &#123; callback(response); &#125; finally &#123; delete getJSONP[cbnum]; script.parentNode.removeChild(script); &#125; &#125;; script.src = url; document.body.appendChild(script);&#125;getJSONP.counter = 0; JSONP有哪些安全问题，怎样处理(白名单过滤)JSON 劫持“JSON Hijacking”，属于CSRF（Cross-site request forgery跨站请求伪造）攻击范畴。采用JSONP的方式来跨域（一般为子域）传递用户认证后的敏感信息时，攻击者可以构造恶意的JSONP调用页面，诱导被攻击者访问来达到截取用户敏感信息的目的。解决方案一：验证JSON文件调用的来源Referer。这个方案是主要利用了script远程加载JSON文件时会发送Referer，在网站输出JSON数据时判断Referer是不是白名单合法的就可以进行防御。解决方案而：通过部署随机token来防御 参考资料Ajax 知识体系大梳理关于跨域，你想知道的全在这里跨域的简易实现和测试","tags":[{"name":"笔试面试","slug":"笔试面试","permalink":"https://wongyirong.github.io/tags/笔试面试/"}]},{"title":"ES6问题整理","date":"2017-10-03T07:50:38.000Z","path":"2017/10/03/032/","text":"对面试中的ES6相关问题进行整理，promise已在上一篇JavaScript异步问题整理介绍过，此处不再赘述。 ES6的新特性1、let所声明的变量只在let命令所在的代码块有效2、const声明一个只读的常量，一旦声明，常量的值就不能改变，必须立即初始化。只声明不赋值就会报错。 const保证的不是变量的值不得变动，而是变量指向的那个内存地址不得改动。 let和const 1.块级作用域2.不存在变量提升，报错ReferenceError3.暂时性死区，在代码块内，使用let命令声明变量之前，该变量都是不可用的4.不允许在相同作用域内重复声明同一个变量 不用let模拟块级作用域-闭包(function &#123; for(var i = 0; i&lt; count; i++) &#123; alert(i); &#125;&#125;)(); 3.变量的解构赋值从数组和对象中提取值按对应位置对变量进行赋值，称为解构。let [a,b,c] = [1, 2, 3]; 匹配一部分属于匹配不成功，剩下的部分赋值undefined；只匹配部分赋值，不完全解构；等号右边不是数组或者可遍历的对象，报错。 let {bar, foo} = {foo: “aaa”, bar: “bbb”};let {foo:baz} = {foo:”aaa”, bar:”bbb”};baz //“aaa” 对象的解构与数组不同，对象的属性没有次序，变量必须与属性同名才能取到正确的值真正被赋值的是后者 用途：交换变量的值let x = 1;let y = 2;[x,y] = [y,x] 有一道题目就是不使用第三个变量交换两个变量的值 if (a &gt; b) &#123; b = a-b; //b比较小就用b存储ab的差值 a = a-b; b = a + b;&#125; else &#123; a = b - a;//a比较小就用a存储ba的差值 b = b - a; a = b + a;&#125; 从函数中返回多个值 返回的数组或者对象取出这些值。ES6模板字符串也可以 function foo() &#123; return [1, 2, 3];&#125;let [a, b, c] = foo(); 更多参见ES6标准指南44页 4.模板字符串`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 5.扩展运算符spread…将数组变成参数序列替代数组的apply方法Math.max求数组最大元素Math.max.apply(null, [14,3,77])Math.max(...[14,3,77]); //ES6 push将一个数组添加到另一个数组尾部Array.prototype.push.apply(arr1, arr2);arr1.push(...arr2); //ES6 合并数组arr1.concat(arr2); //es5[...arr1, ...arr2]; //es6 字符串变数组[...str]; 带Iterator接口变数组 ES5类数组变成数组是用Array.prototype.slice.apply(arguments)或者Array.prototype.slice.call(arguments);ES6可以使用…扩展运算符[…arguments]还可以使用Array.from(arguments);Array.from将类数组和可遍历对象变成数组Array.of将一组值变数组fill给定值填充数组new Array(3).fill(7) 新的遍历数组方法for…of循环遍历，keys键名 values键值 entries键值对 6.箭头函数用处： 简化回调函数：1.sort的compare函数 ：sort((a, b) =&gt; a - b);2.迭代函数（map some every foreach）的回调函数：[1, 2, 3].map(x =&gt; x * x); 注意事项： 1.函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。它是固定的。2.不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。3.不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。4.不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this所以不能用作构造函数。除了thisarguments、super和new.target三个变量也不存在。不能用call、apply、bind改变this指向 箭头函数 JS递归的缺点 ES6为什么要有尾递归 尾调用自身称为尾递归递归非常耗费内存，因为需要同时保存成百上千个调用帧，很容易发生栈溢出错误。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生栈溢出错误。函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 Fibonacci数列//非尾递归function Fibonacci(n) &#123; if(n &lt;= 1) &#123; return 1; &#125; return Fibonacci(n-1) + Fibonacci(n-2);&#125;//Fibonacci(100)堆栈溢出 //尾递归优化function Fibonacci2(n, ac1 = 1, ac2 = 1) &#123; if(n &lt;= 1) &#123; return ac2; &#125; return Fibonacci2(n-1, ac2, ac1 + ac2);&#125; 7.对象name属性，如果对象的方法是一个Symbol值，那么name属性返回的是这个Symbol值的描述 相等(==)自动转换数据类型严格相等(===) NaN不等于自身，+0等于-0Object.is()比较两个值是否严格相等，NaN等于自身，+0不等于-0 Object.assign()方法用于将源对象所有的可枚举属性复制到目标对象。浅拷贝。继承属性和不可枚举属性是不能拷贝的深浅拷贝es6//assign浅拷贝var obj = &#123; a: 1 &#125;;var copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; a: 1 &#125;//深拷贝 递归属性遍历 使用hasOwnProperty方法过滤掉那些继承自原型链上的属性function clone(obj) &#123; var copy; // Handle the 3 simple types, and null or undefined if (null == obj || \"object\" != typeof obj) return obj; // Handle Object if (obj instanceof Object) &#123; copy = &#123;&#125;; for (var attr in obj) &#123; if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]); &#125; return copy; &#125;&#125;/*借助 JSON 全局对象使用 JSON 全局对象的 parse 和 stringify方法来实现深复制也算是一个简单讨巧的方法。然而使用这种方法会有一些隐藏的坑，它能正确处理的对象只有 Number, String, Boolean, Array, 扁平对象，即那些能够被 json 直接表示的数据结构。*/function jsonClone(obj) &#123; return JSON.parse(JSON.stringify(obj));&#125;var clone = jsonClone(&#123; a:1 &#125;); 8.Symbol 原始数据类型Symbol，表示独一无二的值，可以保证不会与其他属性名产生冲突。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 9.Set和Mapset 方法：add delete has clearWeakSet只能是对象不能是其他类型；弱引用，如果都不引用就会被自动回收 Map键值对（hash结构） 方法set get delete has clearsize属性 ES6中map的实现原理Map类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。Map是综合两者的特性的寻址容易、插入删除也容易的数据结构。Map的实现方式是拉链法。构造方法： 1.直接定址法2.除留余数法3.数字分析法4.平方取中法5。折叠法 处理冲突的方式： 1.开放地址法包括线性探测、平方探测、再散列和伪随机序列法2.链地址法 10.Proxy和Reflect Proxy其功能非常类似于设计模式中的代理模式，该模式常用于三个方面： 拦截和监视外部对对象的访问降低函数或类的复杂度在复杂操作前对操作进行校验或对所需资源进行管理 在支持 Proxy 的浏览器环境中，Proxy 是一个全局对象，可以直接使用。Proxy(target, handler) 是一个构造函数，target 是被代理的对象，handlder 是声明了各类代理操作的对象，最终返回一个代理对象。外界每次通过代理对象访问 target 对象的属性时，就会经过 handler 对象，从这个流程来看，代理对象很类似 middleware（中间件）。那么 Proxy 可以拦截什么操作呢？最常见的就是 get（读取）、set（修改）对象属性等操作，完整的可拦截操作列表请点击这里。此外，Proxy 对象还提供了一个 revoke 方法，可以随时注销所有的代理操作。 Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。 （1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。（2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。（3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。（4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 参考资料实例解析ES6 Proxy使用场景 模块化, webpack, AMD和CMDcommonJS和AMD还有ES6本身的模块化的区别？ES6是怎么实现继承的promise，async，awaitH5新特性和ES6新特性es5和es6有什么区别写个继承，es6继承是如何做到的ES6中的继承（class）class 是把什么绑定在了什么上面？es6实现类继承es5，es6面向对象的写法。ES6模块机制promise方法如何使用，分什么状态柯里化函数解决,但是没写出来,面试官提示ES6. ES6特性如下1.块级作用域 关键字let, 常量const 2.对象字面量的属性赋值简写（property value shorthand）var obj = &#123; // __proto__ __proto__: theProtoObj, // Shorthand for ‘handler: handler’ handler, // Method definitions toString() &#123; // Super calls return \"d \" + super.toString(); &#125;, // Computed (dynamic) property names [ 'prop_' + (() =&gt; 42)() ]: 42&#125;; 3.赋值解构let singer = &#123; first: \"Bob\", last: \"Dylan\" &#125;;let &#123; first: f, last: l &#125; = singer; // 相当于 f = \"Bob\", l = \"Dylan\"let [all, year, month, day] = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/.exec(\"2015-10-25\");let [x, y] = [1, 2, 3]; // x = 1, y = 2 4.函数参数 - 默认值、参数打包、 数组展开（Default 、Rest 、Spread）//Defaultfunction findArtist(name='lu', age='26') &#123; ...&#125;//Restfunction f(x, ...y) &#123; // y is an Array return x * y.length;&#125;f(3, \"hello\", true) == 6//Spreadfunction f(x, y, z) &#123; return x + y + z;&#125;// Pass each elem of array as argumentf(...[1,2,3]) == 6 5.箭头函数 Arrow functions (1).简化了代码形式，默认return表达式结果。 (2).自动绑定语义this，即定义函数时的this。如上面例子中，forEach的匿名函数参数中用到的this。 6.字符串模板 Template stringsvar name = \"Bob\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` // return \"Hello Bob, how are you today?\" Iterators（迭代器）+ for..of 迭代器有个next方法，调用会返回：(1).返回迭代对象的一个元素：{ done: false, value: elem }(2).如果已到迭代对象的末端：{ done: true, value: retVal }for (var n of ['a','b','c']) &#123; console.log(n);&#125;// 打印a、b、c 8.生成器 （Generators） 9.Class Class，有constructor、extends、super，但本质上是语法糖（对语言的功能并没有影响，但是更方便程序员使用）。class Artist &#123; constructor(name) &#123; this.name = name; &#125; perform() &#123; return this.name + \" performs \"; &#125;&#125;class Singer extends Artist &#123; constructor(name, song) &#123; super.constructor(name); this.song = song; &#125; perform() &#123; return super.perform() + \"[\" + this.song + \"]\"; &#125;&#125;let james = new Singer(\"Etta James\", \"At last\");james instanceof Artist; // truejames instanceof Singer; // truejames.perform(); // \"Etta James performs [At last]\" 10.Modules ES6的内置模块功能借鉴了CommonJS和AMD各自的优点：(1).具有CommonJS的精简语法、唯一导出出口(single exports)和循环依赖(cyclic dependencies)的特点。(2).类似AMD，支持异步加载和可配置的模块加载。// lib/math.jsexport function sum(x, y) &#123; return x + y;&#125;export var pi = 3.141593;// app.jsimport * as math from \"lib/math\";alert(\"2π = \" + math.sum(math.pi, math.pi));// otherApp.jsimport &#123;sum, pi&#125; from \"lib/math\";alert(\"2π = \" + sum(pi, pi));Module Loaders:// Dynamic loading – ‘System’ is default loaderSystem.import('lib/math').then(function(m) &#123; alert(\"2π = \" + m.sum(m.pi, m.pi));&#125;);// Directly manipulate module cacheSystem.get('jquery');System.set('jquery', Module(&#123;$: $&#125;)); // WARNING: not yet finalized 11.Map + Set + WeakMap + WeakSet 四种集合类型，WeakMap、WeakSet作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉。// Setsvar s = new Set();s.add(\"hello\").add(\"goodbye\").add(\"hello\");s.size === 2;s.has(\"hello\") === true;// Mapsvar m = new Map();m.set(\"hello\", 42);m.set(s, 34);m.get(s) == 34;//WeakMapvar wm = new WeakMap();wm.set(s, &#123; extra: 42 &#125;);wm.size === undefined// Weak Setsvar ws = new WeakSet();ws.add(&#123; data: 42 &#125;);//Because the added object has no other references, it will not be held in the set 12.Math + Number + String + Array + Object APIs 一些新的APINumber.EPSILONNumber.isInteger(Infinity) // falseNumber.isNaN(\"NaN\") // falseMath.acosh(3) // 1.762747174039086Math.hypot(3, 4) // 5Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2\"abcde\".includes(\"cd\") // true\"abc\".repeat(3) // \"abcabcabc\"Array.from(document.querySelectorAll('*')) // Returns a real ArrayArray.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior[0, 0, 0].fill(7, 1) // [0,7,7][1, 2, 3].find(x =&gt; x == 3) // 3[1, 2, 3].findIndex(x =&gt; x == 2) // 1[1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2][\"a\", \"b\", \"c\"].entries() // iterator [0, \"a\"], [1,\"b\"], [2,\"c\"][\"a\", \"b\", \"c\"].keys() // iterator 0, 1, 2[\"a\", \"b\", \"c\"].values() // iterator \"a\", \"b\", \"c\"Object.assign(Point, &#123; origin: new Point(0,0) &#125;) Proxies 使用代理（Proxy）监听对象的操作，然后可以做一些相应事情。var target = &#123;&#125;;var handler = &#123; get: function (receiver, name) &#123; return `Hello, $&#123;name&#125;!`; &#125;&#125;;var p = new Proxy(target, handler);p.world === 'Hello, world!'; 可监听的操作： get、set、has、deleteProperty、apply、construct、getOwnPropertyDescriptor、defineProperty、getPrototypeOf、setPrototypeOf、enumerate、ownKeys、preventExtensions、isExtensible。 14.Symbols Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的。var key = Symbol(\"key\");var key2 = Symbol(\"key\");key == key2 //false 15.Promises Promises是处理异步操作的对象，使用了 Promise 对象之后可以用一种链式调用的方式来组织代码，让代码更加直观（类似jQuery的deferred 对象）。function fakeAjax(url) &#123; return new Promise(function (resolve, reject) &#123; // setTimeouts are for effect, typically we would handle XHR if (!url) &#123; return setTimeout(reject, 1000); &#125; return setTimeout(resolve, 1000); &#125;);&#125;// no url, promise rejectedfakeAjax().then(function () &#123; console.log('success');&#125;,function () &#123; console.log('fail');&#125;);","tags":[{"name":"笔试面试","slug":"笔试面试","permalink":"https://wongyirong.github.io/tags/笔试面试/"}]},{"title":"JavaScript异步问题整理","date":"2017-10-02T10:50:38.000Z","path":"2017/10/02/031/","text":"ES6 诞生以前，异步编程的方法，大概有下面四种。 回调函数 嵌套问题 回调函数地狱事件监听发布/订阅Promise对象 不是新的语法功能而是一种新的写法允许将回调函数的嵌套写成链式调用Generator函数 协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。但是用 generator 处理异步还是离不了 tj/co ，并且还有一些坑爹 bug 和兼容性问题async/await 没有callback代码结构又回到了我们所熟悉并且好看的 “序列结构” 了。返回值是Promise比Generator函数返回Iterator对象方便了许多 Promise 并没有真正消除 callback ，Promise 只不过是用 then 方法来延迟了 callback 的绑定。真正消灭 callback 的 generator 和 async/await Promise对象Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。 优缺点: 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。缺点：1.无法取消Promise，一旦新建它就会立即执行，无法中途取消。2.如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。3.当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 如何使用 Promise对象是一个构造函数Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。 var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value);//将Promise对象的状态从“未完成”变为“成功”，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； &#125; else &#123; reject(error);//将Promise对象的状态从“未完成”变为“失败”，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 &#125;&#125;); Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); //简单例子function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done'); &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); Generator函数 Generator 函数是一个状态机，封装了多个内部状态。Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态。 调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。 只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 promise方法如何使用，分什么状态ES6中如何处理异步，手写一个promise，有哪些状态？es6中异步请求多个数据如何操作ES6中的Promise，怎样实现依次异步回调ES6感受 await、yield、Promisepromise，asyn await，还说了一个es6的一个异步处理关键字，defer关键字Promise方法你最常用什么写法？构造函数传入的参数是什么类型？promise对象中抛出异常如何处理","tags":[{"name":"笔试面试","slug":"笔试面试","permalink":"https://wongyirong.github.io/tags/笔试面试/"}]},{"title":"缓存问题整理","date":"2017-10-01T07:24:53.000Z","path":"2017/10/01/030/","text":"浏览器缓存浏览器缓存策略，时效标志etag标志cookie和session, cookie和webStorage的区别，如果cookie被篡改怎么办前端缓存机制，如果去掉etags\\last-modefied\\cache-control这些控制缓存的字段，浏览器会怎么处理缓存 本地缓存静态文件的web缓存机制 原生js里面怎么操作cookie cors怎么让cookie传过去 怎么给cookie中添加值 cookie的形式，它的一些操作方法 怎么删除cookie，如何使用原生js手动删除","tags":[{"name":"笔试面试","slug":"笔试面试","permalink":"https://wongyirong.github.io/tags/笔试面试/"}]},{"title":"网络编程问题整理","date":"2017-09-30T07:50:38.000Z","path":"2017/09/30/029/","text":"1.常见的响应码401响应类别一共有5种： 1XX Informational(信息性状态码)2XX Success(成功状态码)3XX Redirection(重定向状态码)4XX Client Error(客户端错误状态码)5XX Server Error(服务器错误状态码)HTTP响应状态码有很多，但是实际经常使用的大概只有14个。 200 OK 表示从客户端发来的请求在服务器端被正常处理了。204 No Content 该状态码表示服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。206 Partial Content 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。 301 Moved Permanently 永久性重定向。该状态码表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。302 Found 临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户(本次)能使用新的URI访问。303 See Other 该状态码表示由于请求对应的资源存在另外一个URI，应使用GET方法定向获取请求的资源。 303状态码和302状态码有着相同的功能，但303状态码明确表明客户端应当采用GET方法获取资源。 当301，302，303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文的主体，之后请求会自动再次发送。 301，302标准是禁止将POST方法改变成GET方法的，但实际上使用时大家都会这么做。304 Not Modified 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系。307 Temporary Redirect 临时重定向。该状态码与302 Found有着相同的含义。307会遵照浏览器标准，不会从POST变成GET。 400 Bad Request 该状态码表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容后再次放松请求。401 Unauthorized 该状态码表示发送的请求需要有通过HTTP认证的认证信息，另外若之前已进行过1此请求，则表示用户认证失败。403 Forbidden 该状态码表明对请求资源的访问被服务器拒绝了。404 Not Found 该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 500 Internal Server Error 该状态码表明服务器端在执行请求时发生了错误。503 Service Unavailable 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 post请求传输数据放在哪里，http请求的格式http请求怎么传输数据，如果有文本和文件怎么传，如果有重复的东西https实现原理TCP和UDP的区别TCP怎么检测丢包了进程和线程http连接性能优化，长连接，keep-alive前端安全（XSS、CSRF以及应对措施）https的详细过程，使用的加密算法，是对称加密算法还是非对称加密算法。md5、SHA、AES分别是对称加密的还是非对称加密的http包的格式和解析soket阻塞模式http1.0 和 http2.0 的区别https 的详细过程，从握手到SSL协议，并说出为什么https并没有得到大规模应用http 三次握手，和https握手js如何发送请求，ajax原生写法以及ajax发送的HTTP头部，以及返回的HTTP头部信息，如何修改这些信息","tags":[{"name":"笔试面试","slug":"笔试面试","permalink":"https://wongyirong.github.io/tags/笔试面试/"}]},{"title":"JavaScript原型和继承","date":"2017-09-29T13:04:38.000Z","path":"2017/09/29/028/","text":"原型基于原型链借用构造函数（call和apply）组合继承（原型链和借用构造函数）原型式继承（基于已有的对象创建新对象）寄生式继承（创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象）寄生组合式继承（通过借用构造函数来继承属性，通过原型链的混成形式来继承方法） 继承(JS原型链和继承)[https://juejin.im/post/58f94c9bb123db411953691b]手写寄生组合式继承 闭包//每隔一秒在控制台打印 1-5,经典闭包for(var i = 1; i &lt;= 5; i++) &#123; !function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;(i);&#125;//setTimeout传入第三个参数for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function(num) &#123; console.log(num) &#125;, i * 1000, i);&#125;//ES6 let：for(let i = 1; i &lt;= 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000);&#125;//用 bindfor(var i = 1; i &lt;= 5; i++) &#123; setTimeout(console.log.bind(console, i), i * 1000);&#125; this指向问题function getThis() &#123; console.log(this)&#125;getThis(); //Window var ObjectB = &#123; getThis: getThis&#125;ObjectB.getThis() //Object var getThisA = ObjectB.getThisgetThisA() //Window 其实在JS中this指向的是执行上下文，也就是执行这个函数的对象。像第一次执行执行的对象是全局Window，而第二次执行是ObjectB，第三次执行也是全局Window。根据这个原理，我们只要改变执行函数的对象就能改变this的指向。执行函数的方式有以下方式： 直接调用作为对象的方法调用call和apply方法bind方法 call、apply和bind方法var getThis = function() &#123; console.log(this)&#125;function ObjectA() &#123;&#125;objectA = new ObjectA() // 直接执行时getThis的this指向console.log(\"直接执行时getThis的this指向\")getThis(); //window // call方法改变getThis中this的指向console.log(\"call方法改变getThis中this的指向\")getThis.call(objectA); //ObjectA // apply方法改变getThis中this的指向console.log(\"apply方法改变getThis中this的指向\")getThis.apply(objectA); //ObjectA // bind方法改变getThis中this的指向console.log(\"bind方法改变getThis中this的指向\")var newGetThis = getThis.bind(objectA)newGetThis(); //ObjectA call，apply和bind方法可以改变函数中this的指向。 apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；apply 、 call 、bind 三者都可以利用后续参数传参；bind是返回对应函数，便于稍后调用；apply、call则是立即调用 。讲的特别清楚的apply、call、bing 箭头函数this的指向一定是声明它的对象var ObjectA = function() &#123; this.getThis = () =&gt; &#123; console.log(this); &#125;, this.otherGetThis = function() &#123; console.log(this); &#125;&#125;;var objectA = new ObjectA();var getThis = objectA.getThis;console.log(\"箭头函数this指向\");getThis();//ObjectAvar otherGetThis = objectA.otherGetThis;console.log(\"普通函数this指向\");otherGetThis();//windows 箭头函数的指向是没有改变的，还是指向ObjectA。而普通函数this指向了调用它的全局Window。 类型检测在JS中有 instanceof 和 typeof 两个关于类型检测的运算符，在《JavaScript高级程序设计》中有这种说法：当检测的是基础类型的时候使用typeof更好，而当检测的是引用类型的时候使用 instanceof 更好var ObjectA = function() &#123;&#125;var objectA = new ObjectA()console.log(\"获取objectA的类型\")console.log(typeof objectA) //objectconsole.log(\"判断objectA是否为Object的引用\")console.log(objectA instanceof Object) //trueconsole.log(\"判断objectA是否为ObjectA的引用\")console.log(objectA instanceof ObjectA) //true var num = 1console.log(\"判断num的类型\") console.log(typeof num)//numberconsole.log(\"判断num是否为Number的引用\")console.log(num instanceof Number)//false num = new Number(1)console.log(\"判断重新赋值的num的类型\")console.log(typeof num) //objectconsole.log(\"判断重新赋值的num是否为Number的引用\")console.log(num instanceof Number) //true typeof检测的结果是基本类型：number、string、undefined、boolean、object，要注意的是 null 和数组使用 typeof 运算符得到的也是 object。 而 instanceof 运算符可以精确到是哪一种类型的引用，但 instanceof 也有一个缺陷就是对于直接赋值的数字，字符串，布尔值以及数组是不能将其识别为Number，String，Boolean，Array。 判断数组和对象的方法（典型的有三种，toString，instanceof，constructor） 使用Symbol.toStringTag的方法获取各种类型的tag，其中Number类型的tag为[object Number]，以此类推。而自定义的属性可一通过重写get[Symbol.toStringTag]来自定义tagclass ObjectA &#123; get [Symbol.toStringTag]() &#123; return \"ObjectA\"; &#125;&#125;var objectA = new ObjectA()console.log(\"获取自定义类型的类型\")console.log(Object.prototype.toString.call(objectA))//[object ObjectA]var num = 1console.log(\"获取普通类型的对应的类型\")console.log(Object.prototype.toString.call(num))//[object Number]num = new Number(1)console.log(\"获取引用类型的类型\")console.log(Object.prototype.toString.call(num))//[object Number] 通过这种方法无论是直接赋值还是构造函数赋值，无论是内置类型还是自定义类型都能够识别，相对来说是比较通用的解决办法。 JavaScript This 的六道坎 bind apply call 手写Function.bind函数1.Function.bind返回的也是一个函数，所以注定发生了闭包，2.在返回的这个函数中去调用一个其他的函数，这其实本质上就是函数钩子(HOOK)实现的要点：1.保持函数的this指向2.保持函数的所有参数都传递到目标函数3.保持函数的返回值if (!Function.prototype.bind) &#123; Function.prototype.bind = function(oThis) &#123; if (typeof this !== \"function\") &#123; throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\"); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function() &#123;&#125;, fBound = function() &#123; return fToBind.apply(this instanceof fNOP ? this : oThis || this, aArgs.concat(Array.prototype.slice.call(arguments))); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; &#125;;&#125; 迅雷前端笔试bind/*实现bind函数*/Function.prototype.bind = function () &#123; var self = this.self || this, context = [].shift.call(arguments), args = [].slice.call(arguments), res = function () &#123; return self.apply(context, [].concat.call(args, [].slice.call(arguments))); &#125; res.self = this; return res;&#125;; 作用域链作用域， 原型链，闭包。手写一个闭包，并分析作用域。什么情况下，闭包会导致内存泄漏，手写给个例子。/*首先定义了一个叫Foo的函数，之后为Foo创建了一个叫getName的静态属性存储了一个匿名函数，之后为Foo的原型对象新创建了一个叫getName的匿名函数。之后又通过函数变量表达式创建了一个getName的函数，最后再声明一个叫getName函数。*/function Foo() &#123; getName = function () &#123; alert (1); &#125;; return this;&#125;Foo.getName = function () &#123; alert (2);&#125;;Foo.prototype.getName = function () &#123; alert (3);&#125;;var getName = function () &#123; alert (4);&#125;;function getName() &#123; alert (5);&#125;//请写出以下输出结果：Foo.getName();//2getName();//4Foo().getName();//1getName();//1new Foo.getName();//2new Foo().getName();//3new new Foo().getName();//3 (具体查看)[http://www.cnblogs.com/xxcanghai/p/5189353.html](大部分人都会做错的经典JS闭包面试题)[http://www.cnblogs.com/xxcanghai/p/4991870.html] 垃圾回收机制js内存泄露如何处理 JavaScript 内存泄露 实现深拷贝的方法//判断是对象var isObject = function(obj)&#123; return Object.prototype.toString.call(obj) === '[object Object]'&#125;//判断是数组var isArray = Array.isArray || function(obj)&#123; return Object.prototype.toString.call(obj) === '[object Array]'&#125;//获取对象不在原型上的键var get_keys = function(obj)&#123; var keys = []; for(key in obj)&#123; if(hasOwnProperty.call(obj,key))&#123; keys.push(key); &#125; &#125; return keys;&#125;//实现深拷贝var deepCopy = function(obj)&#123; var temp ; if(isArray(obj))&#123; temp = []; for(var i = 0 ; i &lt; obj.length ; i++)&#123; if(isArray(obj[i])||isObject(obj[i]))&#123; //当前项是数组或者对象，递归调用 temp.push(deepCopy(obj[i])); &#125;else&#123; temp.push(obj[i]); &#125; &#125; &#125;else if(isObject(obj))&#123; temp = &#123;&#125;; var keys = get_keys(obj); var length = keys.length ; for(var i = 0 ; i &lt; length ; i++)&#123; //将对象值递归,结果赋值到新创建的temp对象的key[i]属性。 temp[keys[i]] = deepCopy(obj[keys[i]]) &#125; &#125;else&#123; //传入其他类型直接返回。 return obj; &#125; return temp ;&#125; 迅雷笔试 ： 实现一个map，参数为函数Array.prototype.map = function() &#123; //arguments为类数组对象，如果要取第一个参数为arguments[0] const fn = arguments[0]; //map里的回调函数 const res = []; for (let i = 0; i &lt; this.length; i++) &#123; res.push(fn(this[i]));//执行回调函数的返回值组成新数组 &#125; return res;&#125;/*---------------测试---------------------------*/const arr = [1, 2, 3];const result = arr.map(function(item, index, array) &#123;//回调函数的三个参数，item index array return item * 2;&#125;)console.log(result); 参考资料前端面试题小集","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"笔试面试知识点整理","date":"2017-09-28T08:50:38.000Z","path":"2017/09/28/027/","text":"从8月12参加网易内推笔试开始，秋招现在完成进行时一个多月，大大小小的考试经历了二十余场，面试经历近十场，踏上社会的征途道阻且艰，从一开始的迷失到现在的坚定清晰，个中滋味不亲身体验不足向外人道。所有经历过的都值得感激，所有要来的都值得等待。最可贵人生虽无回头路，但总是充满机会和巧合，在我知道方向和不足亟待停下脚步整顿行装的时候，秋招暂停了！接下来的十天，希望能回望来时路，总结经验，十数天后再次远行。 迅雷选择题1.setInterval(check,10) check函数延迟10毫秒执行一次 2.Str = \"This apples costs \" + 50.5; //This apples costs 50.5 3.var x = [0];if([0]) &#123; console.log(x == true); //false&#125; else&#123; console.log(\"false\");&#125; 4.var a = Array(3);a[0] = 8;a.map(function(elem) &#123; return \"2\";&#125;); //[\"2\", undefined × 2]//[[3, 2, 1].reduce(Math.pow), []. (Math.pow)] //错误 5.js跨域 域名、端口、协议任意一个不同就是跨域使用jsonp进行跨域通过修改document.domain来跨子域使用window.name来进行跨域 6.function show() &#123;&#125;delete show.length;console.log(typeof show.length); //number 7.(function ()&#123; var x = foo(); var foo = function foo() &#123; return \"foobar\"; &#125;; return x;&#125;)();//类型错误*/ 8.Ajax 你已经创建了一个XMLHttpRequest对象xhr，正确调用了对象的open方法和send方法。当你检查 xhr.status 时发现等于0，responseText是空。原因是：请求被撤销了，因为连接错误或用户的操作 9.制作级联菜单功能时调用的是下拉列表框的onChange事件 10.返回falseif (undefined) &#123; //false console.log('true');&#125; else &#123; console.log('false');&#125;if (null) &#123; //true console.log('true');&#125; else &#123; console.log('false');&#125;if (0) &#123; //true console.log('true');&#125; else &#123; console.log('false');&#125;if (\"0\") &#123; //false console.log('true');&#125; else &#123; console.log('false');&#125; 11.浏览器对象 Location 对象包含有关当前 URL 的信息。History 对象包含用户（在浏览器窗口中）访问过的 URL。window对象是所有页面内容的根对象document对象包含form对象 12.JavaScript对象 JavaScript对象有两种不同的属性，一种是对象自身的属性，另一种是继承于原型链的属性JavaScript中几乎所有的对象都是 Object 的实例; 所有的对象都继承了Object.prototype的属性和方法只有构造函数才有prototype属性。构造器的prototypeconstructor指向它自身 13.要改变层中内容可以使用的方法有： innerText和innerHTML 14.css position:relative的top、right、bottom、left相对于它在正常流中的默认位置偏移position:absolute相对于static定位以外的第一个父元素进行定位rem作为元素尺寸单位时，相对于文档根元素的 font-size 大小进行计算（例如 html元素的font-size）。当用在根元素的font-size上面时 ，它代表了它的初始值box-sizing属性，content-box，默认属性，遵从标准盒模型。border-box，是使用IE盒模型。 15.radio定义单选按钮，有check属性，会触发 onclick 事件句柄&lt;input type=\"radio\" name=\"sex\" value=\"male\" checked&gt;Male 16.var obj1 = &#123; x: 5 &#125;;var obj2 = obj1;obj1.a = obj1 = &#123; x: 6 &#125;;console.log(obj1.a); //undefinedconsole.log(obj2.a); //[object Object] 17.(function() &#123; var b = a = 1;&#125;)(); //a=1 b is not defined 18.经典闭包问题for (var i = 1; i &lt; 5; i++) &#123; setTimeout((function(i) &#123; return function() &#123; console.log(i); &#125; &#125;)(i), i*1000);&#125; 立即执行函数var key = [];for (var i = 0; i &lt; 5; i++) &#123; (function() &#123; var x = i; key[i] = function() &#123; console.log(x) &#125; &#125;)();&#125;for (i = 0; i &lt; key.length; i++) &#123; key[i](); //0、1、2、3、4&#125; 5个4var key=[];for(var i = 0;i&lt;5;i++)&#123; var x = i; key[i] = function()&#123; console.log(x) &#125;&#125;for(i = 0; i &lt; key.length; i++) &#123; key[i](); //5个4&#125; key[i]里面仅仅只是存着函数而没有运行，所以它并没有和代码片段中的循环同时运行。var声明的变量属于函数作用域，所以对于B段代码而言，无论你循环多少次，x和i都只有1个，这也就意味着key[i]函数里面存着的，对x的引用都是同一个。所以当key[i]的函数运行的时候，它们引用的都是同一个x =4，那么当然打印出来的就是5个4了。对于A段代码而言，每次循环迭代都创建了个新的函数作用域，而其作用域内部的x当然也就随之创建了5个。这也就意味着，A段代码中key[i]函数中对于x的引用并不是同一个，而是每次迭代之中关于i的副本。所以，A段代码可以连续输出i的值。它们之中的区别就在于，B段代码之中引用的x是同一个，而A段代码中并不是。 19.事件监听 1、IE使用attachEvent和detachEvent方法来添加和删除事件监听器，w3c使用addEventListener/removeEventListener方法。2、IE对其事件使用onevent的命名方式，而w3c的是event的命名方式。3、IE事件监听器内使用的是一个全局的Event对象，而w3c是将event对象作为参数传递给监听器。4、为了避免触发默认的事件行为，IE的做法是要求程序员设置Event对象中的returnValue属性值为false，而w3c的做法是执行preventDefault方法。5、IE没有提供对事件捕获阶段的支持。6、要停止事件的传递，IE的做法是设置event对象的cancelBubble为true，而w3c的做法是设置执行stopPropagation方法。 20.填空题1)function bar() &#123; return foo; foo = 10; function foo() &#123;&#125; var foo = 11;&#125;console.log(typeof bar()); //function 2)var foo = 1;function bar2() &#123; foo = 10; return; function foo() &#123;&#125;&#125;bar2();console.log(foo); //1 3)function foo2(a) &#123; arguments[0] = 2; console.log(a);&#125;foo2(1); //2 4)var x = 3;var foo3 = &#123; x: 2, baz: &#123; x: 1, bar: function() &#123; return this.x; &#125; &#125;&#125;var go = foo3.baz.bar;console.log(go()); //2console.log(foo3.baz.bar()); //1 5)x1 = &#123;&#125;;function bar2() &#123; this.x1 = 2; return x1;&#125;var foo4 = new bar2();console.log(foo4.x1); //undefined 6)var x = 2017;var y = 2018;(function() &#123; var x = 2018; y = 2017;&#125;)(); //x还是2017 y变成了2017 7)console.log(undefined === null); //falsevar i = 2;console.log(++i == 2); //falseconsole.log(1 === '1'); //falseconsole.log(\"\" == 0); //true 8)console.log(typeof 'string'); //stringconsole.log(String('string').toString()); //stringconsole.log('string'.split('').sort().join('')); //ginrst sort改变原位置console.log((function(string) &#123; return string &#125;)('string')); //stringconsole.log(JSON.parse('&#123;\"string\":\"string\"&#125;').string); //string 用友笔试题1.打印出2//2.toString(); 报错2.toString(); //\"2\"2..toString(); //\"2\"(2).toString(); //\"2\" 2.es6let s = Symbol();console.log(typeof s); //symbol 3.Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);console.log(target) // &#123;a:1, b:2, c:3&#125; 4.reduce()方法const initState = '';const actions = ['a', 'b', 'c'];const newState = actions.reduce((prevState, action) =&gt; &#123; return prevState + action &#125;, initState);console.log(newState); //abc 5.object数组，根据对象属性长度排序var a = &#123; name: 'Schoolar', age: 35, like: 'javascript'&#125;;var b = &#123; name: 'kitty', food: 'fish'&#125;;var c = &#123; door: 'four'&#125;;var object = [a, b, c];object.sort(function compare(a, b) &#123; return Object.getOwnPropertyNames(a).length - Object.getOwnPropertyNames(b).length;&#125;);console.log(object); 用友面试题1.类数组function printArgs() &#123; Array.prototype.forEach.call(arguments, function(arg, i) &#123; console.log(i + ':' + arg); &#125;);&#125;printArgs('a', 'b'); //0:a 1:b 类数组转成数组function list() &#123; return Array.prototype.slice.call(arguments); //当slice()没有输入参数的时候，会创建一个新数组，然后把当前数组的所有元素扔进去，最后返回这个新数组。&#125;console.log(list(1, 2, 3)); // [1, 2, 3] 2.window.onload用以保证页面的所有资源都加载完毕后才执行当中的js代码 原生JS实现DOMReady事件function myDOMReady(fn)&#123; //判断如果支持addEc=ventListener（非IE--IE支持的是attachEvent）则绑定DOMContentLoaded事件 if(document.addEventListener)&#123; document.addEventListener(\"DOMContentLoaded\",fn,false); &#125;else&#123; IEContenLoaded(fn); &#125; //IE下模拟DOMContentLoaded function IEContenLoaded(fn)&#123; var done = false; //只执行一次用户的回调函数init var init = function()&#123; if(!done)&#123; done = true; fn(); &#125; &#125; (function()&#123; try&#123; //DOM树未创建完之前调用doScroll会抛出错误 window.document.documentElement.doScroll(\"left\"); &#125;catch(error)&#123; //延迟再执行，arguments.callee调用自己 setTimeout(argument.callee,1); return; &#125; //没有错误表示DOM树创建完毕，执行用户回调 init(); &#125;)(); //监听document的加载状态 window.document.onreadystatechange = function()&#123; //如果用户是在DOMReady之后调用的函数立即执行用户回调 if(window.document.readyState == 'complete')&#123; window.document.onreadystatechange=null; init(); &#125; &#125; &#125;&#125; 3.静态资源独立部署 1、启用新的一级域名，每次请求浏览器不会携带cookie。这对于cookie内容比较大，并且流量大的网站会省去不少宽带费用。当浏览器向服务器请求一个静态资源时,会先发送同域名下的 cookie，服务器对于这些 cookie 不会做任何处理。因此它们只是在毫无意义的消耗带宽。2、动静分离。静态资源与动态内容分离，有利于部署于CDN。3、HTTP协议对同一个域名的同时下载线程数有限制。主要是为了优化下载速度，防止同一域名下下载线程数过多，导致下载速度变慢。各个浏览器都会遵守这个规定，但是限制的数目可能不一致。基于这个原因，可将资源部署于不同的域名，以达到最大化并发下载。4、静态资源独立部署，为全局产品服务。方便复用，放在一个服务器上的文件可以共其他服务器上的产品使用。 比如taobao.com和tmll.com都会用到tbcdn.cn上的静态资源，这些资源不必从属于某个产品。这样同时也有利于最大化利用客户端缓存。比如访问taobao.com，缓存了tbcdn.cn上的某个js文件，之后再访问tmll.com时，也用到此js文件，不必再从tbcdn.cn上下载，直接用客户端缓存即可","tags":[{"name":"笔试面试","slug":"笔试面试","permalink":"https://wongyirong.github.io/tags/笔试面试/"}]},{"title":"JavaScript的遍历","date":"2017-09-22T10:50:38.000Z","path":"2017/09/22/026/","text":"1.for/while循环语句最常见的遍历方法，for/while能力有限，而且性能上也堪忧。必须借助特定的结构才能遍历数据结构。 2.for…in语句 适用对象var obj = &#123; a:\"1\", b:\"2\", c:\"3\"&#125;;for(var key in obj) &#123; console.log(obj[key]);&#125; 优点：支持所有对象类型的数据，包括数组，甚至是函数等。缺点：不仅遍历普通属性，也遍历原型链上的属性。建议：在遍历常用对象时使用（不适用Map） 3.for…of ES6新增 适用map遍历数组for (var value of [1,2,3]) &#123; console.log(value);&#125; 遍历字符串for (var chr of \"123\") &#123; console.log(chr);&#125; 遍历Mapvar list = new Map().set('a',1).set('b',2).set('c',3);for (var [key,value] of list) &#123; console.log(key + '=&gt;' + value);&#125; 不可用于遍历对象的属性，但可以与内建的Object.keys()方法一起使用// 向控制台输出对象的可枚举属性for (var key of Object.keys(obj)) &#123; console.log(key + \": \" + obj[key]);&#125; 还可以遍历类数组对象，Set等优点：可以遍历任何部署了Iterator接口的数据结构，甚至是非JavaScript的数据类型正确响应break、continue和return语句缺点：不能用来遍历普通对象。建议：推荐使用，最简洁强大的循环语句。 4.ES5的数组迭代方法 遍历数组forEach()方法 对数组每一项运行给定的函数，没有返回值var nums = [1,2,3];nums.forEach( function(element, index) &#123; console.log(index + \":\" + element);&#125;); map()方法 对数组每一项运行给定的函数，返回每次函数调用的结果组成的数组var doubleNums = nums.map(function (num) &#123; return num * 2;&#125;); //doubleNums存储每次函数调用的结果组成的数组console.log(doubleNums);console.log(nums); filter()方法 对数组每一项运行给定的函数，返回该函数会返回true的项组成的数组var result = nums.filter(x =&gt; x &gt; 1);console.log(result); every()和some()方法 every每一项为true返回true,some有一个为true返回truevar everyRes = nums.every(function(element, index, array) &#123;//传入三个参数，根据需要可选 return (element &gt; 1);&#125;);console.log(everyRes); //falsevar someRes = nums.some(function(element, index, array) &#123; return (element &gt; 1);&#125;);console.log(someRes); //true 缺点：仅支持数组。而且一旦调用，会完全遍历一次，break, continue, return都无效。建议：仅在遍历数组的时候使用。 5.ES5的数组归并方法reduce()和reduceRight()迭代数组的所有项，然后构建一个最终返回的值reduce()从数组的第一项开始，reduceRight()是从数组的最后一项开始两个方法都接收两个参数：在每一项上调用的函数和作为归并基础的初始值（可选）调用函数传入四个参数，前一个值，当前值，项的索引和数组的对象var values = [1, 2, 3, 4];var sum = values.reduce(function(pre, cur, index, array) &#123; return pre + cur;&#125;);console.log(sum);","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"git常用操作总结","date":"2017-09-12T00:50:38.000Z","path":"2017/09/12/025/","text":"本文将对面试中遇到的Git版本控制的问题进行整理。 创建初始化一个Git仓库 git init添加文件到Git仓库，分两步：第一步，添加文件 git add file 把文件修改添加到暂存区第二步，提交到仓库 git commit -m “” 把暂存区的所有内容提交到当前分支查看工作区的状态 git status查看修改内容 git diff 版本回退：显示从最近到最远的提交日志 git log回到上一次修改的版本 git reset –hard HEAD^不想回到上一次修改的版本了 git reset –hard 版本号记录你的每一次命令 git reflog回到最近一次git commit或git add时的状态 git checkout – file 丢弃工作区的修改把暂存区的修改撤销掉（unstage） git reset HEAD file 再一次git checkout – file 删除文件删除工作区文件 rm file然后从版本库中删除该文件 git rm file 然后git commit如果想恢复工作区的文件可从版本库回复 git checkout – file 远程仓库关联一个远程库：git remote add origin git@github:wongyirong/gitReview.git第一次推送master分支的所有内容: git push -u origin master此后，每次本地提交后，推送最新修改：git push origin master 分支查看分支：git branch创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d BUG分支先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash 要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。 如何解决代码冲突先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：git pullgit merge &lt;name&gt;//手动解决冲突git add git commitgit push 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息git merge –no-ff -m “merge with no-ff” name合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 多人协作的工作模式首先，可以试图用git push origin branch-name推送自己的修改；如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；如果合并有冲突，则解决冲突，并在本地提交；没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name rebase和merge的区别当你在一个特定的分支开发新功能，团队的其它成员在master分支工作提交了新的commit。这个项目的历史就会分叉。如果你想要你的分支中包含master中的commit，可以选择merge或者rebase merge把master分支上的修改pull下来并且和你的修改合并:git pullgit checkout namegit merge master 结果是在你的分支上创建一个”合并的提交”(merge commit) rebase会把你的分支的commit放到mager分支之后, rebase不会创建一个”merge commit”, rebase会为你分支的每个commit创建一个新的commit.git checkout namegit rebase master 使用rebase主要的一个好处是你的项目历史比较干净. 首先, rebase不再有merge commit. 第二, 从上图来看使用rebase项目的历史不会分叉. 解决冲突方式：在rebase的过程中，也许会出现冲突(conflict).在这种情况，Git会停止rebase并会让你去解决 冲突；在解决完冲突后，git add //然后无需执行git-commitgit rebase --continue 在任何时候，你可以用–abort参数来终止rebase的行动，并且自己的分支会回到rebase开始前的状态。git rebase --abort merge vs rebasegit merge 和 git rebase 小结 pull和fetch的区别pull和fetch的作用都是从远程的分支获取最新的版本到本地。 git fetch：相当于是从远程获取最新版本到本地，不会自动merge，可使用git diff和git merge命令进行比较合并 git pull：相当于是从远程获取最新版本并merge到本地 git pull相当于git fetch 和 git merge在实际使用中，git fetch更安全一些因为在merge前，我们可以查看更新情况，然后再决定是否合并 参考资料Git教程","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"面试问题收集整理","date":"2017-08-25T07:04:23.000Z","path":"2017/08/25/024/","text":"前端常见面试问题收集整理 JavaScript数组方法数组方法JavaScript 数组方法对比 水平居中垂直居中水平居中 1) 若是行内元素, 给其父元素设置 text-align:center,即可实现行内元素水平居中.2) 若是块级元素, 该元素设置 margin:0 auto即可. 3) 若子元素包含 float:left 属性, 为了让子元素水平居中, 则可让父元素宽度设置为fit-content,并且配合margin, 作如下设置:.parent&#123; width: -moz-fit-content; width: -webkit-fit-content; width:fit-content; margin:0 auto;&#125; fit-content是CSS3中给width属性新加的一个属性值,它配合margin可以轻松实现水平居中, 目前只支持Chrome 和 Firefox浏览器. 4) 使用flex布局, 可以轻松的实现水平居中, 子元素设置如下:.son&#123; display: flex; justify-content: center;&#125; 5) 使用CSS3中新增的transform属性, 子元素设置如下:.son&#123; position:absolute; left:50%; transform:translate(-50%,0);&#125; 6) 使用绝对定位方式, 以及负值的margin-left, 子元素设置如下:.son&#123; position:absolute; width:固定; left:50%; margin-left:-0.5宽度;&#125; 7) 使用绝对定位方式, 以及left:0;right:0;margin:0 auto; 子元素设置如下:.son&#123; position:absolute; width:固定; left:0; right:0; margin:0 auto;&#125; 垂直居中 1) 若元素是单行文本, 则可设置 line-height 等于父元素高度2) 若元素是行内块级元素, 基本思想是使用display: inline-block, vertical-align: middle和一个伪元素让内容块处于容器中央..parent::after, .son&#123; display:inline-block; vertical-align:middle;&#125;.parent::after&#123; content:&apos;&apos;; height:100%;&#125; 这是一种很流行的方法, 也适应IE7. 3) 元素高度不定，可用 vertical-align 属性, 而vertical-align只有在父层为 td 或者 th 时, 才会生效, 对于其他块级元素, 例如 div、p 等, 默认情况是不支持的. 为了使用vertical-align, 我们需要设置父元素display:table, 子元素 display:table-cell;vertical-align:middle; 优点：元素高度可以动态改变, 不需再CSS中定义, 如果父元素没有足够空间时, 该元素内容也不会被截断.缺点：IE6~7, 甚至IE8 beta中无效. 4) 元素高度不定，可用Flex，Flexbox是CSS3新增属性 父元素做如下设置即可保证子元素垂直居中:.parent &#123; display: flex; align-items: center;&#125; 优点内容块的宽高任意, 优雅的溢出.可用于更复杂高级的布局技术中.缺点IE8/IE9不支持需要浏览器厂商前缀渲染上可能会有一些问题 5) 元素高度不定，可用 transform , 设置父元素相对定位(position:relative), 子元素如下css样式:.son&#123; position:absolute; top:50%; -webkit-transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%); transform: translate(-50%,-50%);&#125; 优点:代码量少缺点:IE8不支持, 属性需要追加浏览器厂商前缀, 可能干扰其他 transform 效果, 某些情形下会出现文本或元素边界渲染模糊的现象. 6) 元素高度固定，设置父元素相对定位(position:relative), 子元素如下css样式:.son&#123; position:absolute; top:50%; height:固定; margin-top:-0.5高度;&#125; 优点:适用于所有浏览器.缺点:父元素空间不够时, 子元素可能不可见(当浏览器窗口缩小时,滚动条不出现时)。如果子元素设置了overflow:auto, 则高度不够时, 会出现滚动条。 7) 元素高度固定，设置父元素相对定位(position:relative), 子元素如下css样式:.son&#123; position:absolute; height:固定; top:0; bottom:0; margin:auto 0;&#125; 优点:简单缺点:没有足够空间时, 子元素会被截断, 但不会有滚动条. 总结 水平居中较为简单, 共提供了7种方法, 一般情况下 text-align:center,marin:0 auto; 足矣 ① text-align:center;② margin:0 auto;③ width:fit-content;④ flex⑤ transform⑥ ⑦ 两种不同的绝对定位方法 垂直居中, 共提供了7种方法. ① 单行文本, line-height② 行内块级元素, 使用 display: inline-block, vertical-align: middle; 加上伪元素辅助实现③ vertical-align④ flex⑤ transform⑥ ⑦ 两种不同的绝对定位方法 我们发现, flex, 盒模型, transform, 绝对定位, 这几种方法同时适用于水平居中和垂直居中.(参考)[https://juejin.im/post/58f818bbb123db006233ab2a] 前端面试题目 top15 系列说一下你对 CSS 盒模型的理解？ 盒模型包括的属性 box-sizing 简单说下 flexbox 布局？ flexbox 布局解决的问题（未出现之前，布局的缺陷） flexbox 的兼容性 flexbox 的局限（引出 grid 布局） 说下你对 CSS3 动画的理解？ transition animation 动画性能（transform、3D等） 简单说下你对一些小图标的处理？ 雪碧图 iconfont svg sprites 浏览器缓存的头字段有哪些，缓存的逻辑是怎样的？ 缓存 引申：200 和 304 的区别 创建一个有十行十列的表格（不准 innerHTML），并给每个单元格绑定事件。 DOM 操作 事件委托 写个 Person 类，属性 name 公有，属性 age 私有；写个 Student 继承 Person，并有自己的公有属性 grade 和公有方法 getTeacher。 面向对象（变量，方法，私有/公有，继承…） HTTP 常见的状态码，301，302 等；POST 和 GET 的区别。 网络（状态码，请求方法…） 有没有碰到过跨域请求，你是怎么处理的？ 跨域（jsonp，CORS…） 写个正则匹配下邮箱、手机号 正则 接触过哪些构建工具；现在用的是啥；写出你现在项目的目录结构，并解释构建工具的运作方式；有否写过插件？ 构建（fis3、gulp、webpack…） 你写代码的时候是怎么考虑安全因素的？ 安全（xss、csrf…） 给你的代码写过单元测试吗；为了更好地单测你是怎么组织你的代码的；我这里有份代码，你看怎么给每个函数写个单测？ 单元测试（Mocha…） 有没有做过性能优化，都有哪些手段？ 雅虎35条","tags":[{"name":"笔试面试","slug":"笔试面试","permalink":"https://wongyirong.github.io/tags/笔试面试/"}]},{"title":"是Ajax啊","date":"2017-08-11T07:24:53.000Z","path":"2017/08/11/023/","text":"Ajax = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。Ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。Ajax技术的核心是XMLHttpRequest对象（简称XHR），运用XMLHttpRequest对象使后台与服务器进行数据交换，在重新加载页面的情况下取得新数据，再通过DOM操作将新数据插入到页面中。 XMLHttpRequest对象IE7+、Firefox、Chrome、Safari以及Opera都支持原生的XMLHttpRequest对象。在这些浏览器中可以使用XMLHttpRequest构造函数。var xhr = new XMLHttpRequest();在老版本的 Internet Explorer（IE5 和 IE6）使用 ActiveX 对象：variable=new ActiveXObject(“Microsoft.XMLHTTP”); XMLHttpRequest的属性收到响应后，响应的数据会自动填充XHR对象的属性：1.responseText属性:获得字符串形式的响应数据。2.responseXML属性:获得XML形式的响应数据。3.status属性:响应的HTTP状态4.statusText属性:HTTP状态的说明 xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304 5.readyState属性：存有XMLHttpRequest的状态，表示请求/响应过程的当前活动阶段。从0到4发生变化。&emsp;0: 未初始化。尚未调用open()方法&emsp;1: 启动。已经调用open()方法，但尚未调用send()方法&emsp;2: 发送。已经调用send()方法，但尚未接收到响应&emsp;3: 接收。已经接收到部分响应数据&emsp;4: 完成。已经接收到全部响应数据，而且已经可以在客户端使用了 xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200 //响应已就绪 6.onreadystatechange事件readyState的值每变化一次就触发一次onreadystatechange事件，必须在调用open()之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性。 XMLHttpRequest的方法1.open(method,url,async) 规定请求的类型、URL 以及是否异步处理请求。&emsp;method：请求的类型：GET 或 POST&emsp;url：请求的地址，文件在服务器上的位置&emsp;async：true（异步）或 false（同步）默认true 2.send(string) 将请求发送到服务器。send()方法接收一个参数即要作为请求主体发送的数据，如果不需要通过请求主体发送数据（比如GET请求)，则必须传入null（空的话有些浏览器不支持）。POST请求不给参数无意义，所以一般要接收一个string。 3.abort()方法 取消异步请求调用这个方法后，XHR对象会停止触发事件，而且也不再允许访问任何与响应有关的对象属性。将XMLHttpRequest 对象重置为 readyState 为 0 的状态。 4.setRequestHeader（）这个方法只有当 readyState 为 1 的时候才能调用，必须在调用open()方法之后且调用send()方法之前调用setRequestHeader()。然后在 send() 方法中规定您希望发送的数据。setRequestHeader(header,value) 向请求添加 HTTP 头。 5.getAllResponseHeaders()把 HTTP 响应头部作为未解析的字符串返回。如果 readyState 小于 3，这个方法返回 null。否则，它返回服务器发送的所有 HTTP 响应的头部。头部作为单个的字符串返回，一行一个头部。每行用换行符 “\\r\\n” 隔开。 6.getResponseHeader()返回指定的 HTTP 响应头部的值。其参数是要返回的 HTTP 响应头部的名称。可以使用任何大小写来制定这个头部名字，和响应头部的比较是不区分大小写的。该方法的返回值是指定的 HTTP 响应头部的值，如果没有接收到这个头部或者 readyState 小于 3 则为空字符串。如果接收到多个有指定名称的头部，这个头部的值被连接起来并返回，使用逗号和空格分隔开各个头部的值。 GET请求GET请求用于向服务器查询某些信息，可以将查询字符串参数追加到URL的末尾，以便将信息发送给服务器。查询字符串中每个参数的名称和值都必须使用encodeURIComponent()进行编码。 encodeURI() 函数可把字符串作为 URI 进行编码。返回URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换。该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&amp;=+$,#而如果 URI 组件中含有分隔符，比如 ? 和 #，则应当使用 encodeURIComponent() 方法分别对各组件进行编码。encodeURIComponent()：其他字符（;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的 POST请求POST请求的主体可以包含非常多的数据，而且格式不限。在open()方法的第一个参数的位置传入”POST”，就可以初始化一个POST请求。发送POST请求的第二部是向send()方法中传入某些数据。 我们可以将Content-Type头部信息设置为application/x-www-form-urlencoded模拟表单提交 跨源资源共享同源策略是对XHR的一个主要约束，它为通信设置了“相同的域，相同的端口，相同的协议”这一限制。默认情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。这种安全策略可以预防某些恶意行为，但是合理的跨域请求对开发某些浏览器应用程序至关重要。跨域资源共享Cross Origin Resource Sharing(CORS)定义了在必须访问跨域资源时，浏览器与服务器如何沟通。CORS的背后基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求响应是应该成功还是应该失败。 IE对CORS的实现：微软IE8引入了XDR(XDomainRequest)类型。这个对象与XHR类似，但能实现安全可靠的跨域通信。XDR对象的安全机制部分实现了W3C的CORS规范。XDR与XHR的不同之处：&emsp;cookie不会随请求发送也不会随响应返回。&emsp;只能设置请求头部信息中的Content-Type字段&emsp;不能访问响应头部信息&emsp;只支持GET和POST请求这些变化使CSRF(Cross-Site Request Forgery,跨站点请求伪造)和XSS(Cross-Site Scripting,跨站点脚本)的问题得到了缓解。 其他主流浏览器通过XMLHttpRequest对象实现了对CORS的原生支持。要请求位于另一个域中的资源，使用标准的XHR对象并在open()方法中传入绝对URL即可。跨域XHR对象可以访问status和statusText属性，而且支持同步请求。跨域XHR对象也有一些限制：&emsp;不能使用setRequestHeader()设置自定义头部&emsp;不能发送和接收cookie&emsp;调用getAllResponseHeaders()方法总会返回空字符串由于无论同源请求还是跨域请求都是用相同的接口，因此对于本地资源，最好使用相对URL，在访问远程资源时再使用绝对URL 其他跨域技术1.图像Ping图像Ping是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或者204响应。通过图像Ping浏览器得不到任何具体的数据，但通过侦听load和error事件，它能知道响应式什么时候接收到的。图像Ping最常用于跟踪用户点击页面或者动态官高曝光次数。图像Ping有两个主要的缺点，一时之能发送GET请求，二是无法访问服务器的响应文本。因此，它只能用于浏览器与服务器间的单向通信。 2.JSONPJSON with Padding，这里的 Padding 指的就是包裹在 JSON 外层的回调函数AJAX 无法跨域是受到“同源政策”的限制，但是带有src属性的标签（例如script、img、iframe）是不受该政策限制的，因此我们可以通过向页面中动态添加script标签来完成对跨域资源的访问，这也是 JSONP 方案最核心的原理。与图像Ping相比，它的优点是在于能够直接访问响应文本，支持在浏览器与服务器之间双向通信。但它是从其他域中加载代码执行，不能保证安全可靠。其次，确定JSONP请求是否失败并不容易。 JSON一种表示结构化数据的格式。JSON数据的书写格式：名称/值对中间用冒号隔开JSON的值类型：&emsp;简单值：字符串（双引号）、数值、布尔值（true false）和null，但不支持undefined&emsp;对象：一组无序的键值对儿。用{}&emsp;数组：一组有序的值的列表，可以通过数值索引来访问其中的值。用[] 与JS对象不同在于：JSON对象没有声明对象，其次没有末尾的分号，而且对象的属性必须加双引号。数组也没有变量和分号 JSON解析eval()函数可以解析、解释并返回JavaScript对象和数组。但eval()存在风险，尽量不要使用。不能原生支持JSON解析的浏览器，使用shim是最佳选择。 JSON对象有两个方法：stringify() 用于把JavaScript对象序列化为JSON字符串。默认输出的JSON字符串不包含任何空格字符或缩进。可以接收另外两个参数，第一个参数是过滤器（replacer），可以是数组也可以是函数。第二个参数是一个选项，表示是否在JSON字符串中保留缩进，如果这个参数是一个数值，它代表的是每个级别缩进的空格数。还可以给原生的对象定义toJSON()方法，返回其自身的JSON数据格式。 parse() 把JSON字符串解析为原生的JavaScript值。可以接受另一个参数，该参数是一个函数(reviver)，将在每个键值对上调用。","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"凉夜对词","date":"2017-07-31T15:32:15.000Z","path":"2017/07/31/022/","text":"婕叹“时光容易把人抛，红了樱桃，绿了芭蕉”，我怼她“是流光容易把人抛”，她不服，我搬出原文《一剪梅·舟过吴江》 一片春愁待酒浇。江上舟摇，楼上帘招。秋娘渡与泰娘桥，风又飘飘，雨又萧萧。何日归家洗客袍？银字笙调，心字香烧。流光容易把人抛，红了樱桃，绿了芭蕉。 感叹传世名句后继续说起蒋捷另一首闻名于世的《虞美人·听雨》 少年听雨歌楼上，红烛昏罗帐。壮年听雨客舟中，江阔云低，断雁叫西风。而今听雨僧庐下，鬓已星星也。悲欢离合总无情，一任阶前点滴到天明。 婕说她越来越能体会少年壮年的那种变化，她说的时候我好像看到在路上的她。周邦彦的《解连环》 怨怀无托，嗟情人断绝，信音辽邈。纵妙手、能解连环，似风散雨收，雾轻云薄。燕子楼空，暗尘锁、一床弦索。想移根换叶，尽是旧时，手种红药。汀洲渐生杜若。料舟移岸曲，人在天角。谩记得、当日音书，把闲语闲言，待总烧却。水驿春回，望寄我、江南梅萼。拼今生，对花对酒，为伊泪落。 贺铸的《青玉案》 凌波不过横塘路，但目送、芳尘去。锦瑟华年谁与度？月桥花院，琐窗朱户，只有春知处。飞云冉冉蘅皋暮，彩笔新题断肠句。试问闲情都几许？一川烟草，满城风絮，梅子黄时雨。 我说我就是喜欢这种无端端又没什么大追求的小忧伤……就连辛弃疾我都更爱他的《摸鱼儿》。 更能消，几番风雨？匆匆春又归去。惜春长怕花开早，何况落红无数。春且住，见说道，天涯芳草无归路。怨春不语，算只有殷勤，画檐蛛网，镇日惹飞絮。长门事，准拟佳期又误，蛾眉曾有人妒。千金纵买相如赋，脉脉此情谁诉？君莫舞，君不见，玉环飞燕皆尘土。闲愁最苦，休去倚危栏，斜阳正在，烟柳断肠处。 那些壮阔激昂的家国情怀在课本里、在试卷上“体会”了太多，于我而言只有标准答案却没有共情，反而诗词里的儿女情长、伤春悲秋、感时悲逝的情绪最触动我。 夏夜难得的凉爽，有穿堂风过。心情太好，似乎有些难眠。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://wongyirong.github.io/tags/随笔/"}]},{"title":"一个问题引出的正则表达式总结","date":"2017-07-27T00:44:02.000Z","path":"2017/07/27/021/","text":"早上我同学给我发了张截图，让我给她解释一下这段正则的含义。/^(?:([A-Za-z]+):)?(\\/&#123;0,3&#125;)([0-9.\\-A-Aa-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/ 刚开始看觉得好乱，但仔细看一下里面的语法都是熟悉的，我耐下心来，在笔记本画了下草图就感觉比较清晰了，这是一段匹配URL的正则表达式文本。理清后觉得很有必要做一些整理归纳工作，加强对正则表达式的语法记忆，也为自己建立一个参考手册。 regexp对象JavaScript内置对象RegExp实例化有两种方式：1.字面量var reg1 = /\\bbaidu\\b/g;2.构造函数：var reg2 = new RegExp(“\\bbaidu\\b”, “g”); 修饰符g:global 全文搜索 不加g默认找到第一个匹配就停止i:ignore case 忽略大小写 默认是大小写敏感m:multiple lines 多行搜索 元字符元字符是在正则表达式中有特殊含义的非字母字符1.有特殊含义的标点符号* + ? $ ^ . | \\ ( ) &#123; &#125; [ ] 2.直接量字符 字符 含义 字母及数字 自身 \\t 水平制表符 \\v 垂直制表符 \\n 换行符 \\r 回车符 \\0 空字符 \\f 换页符 3.字符类(1)将直接量字符单独放进方括号内就组成了字符类。一个字符类可以匹配它所包含的任意字符。(2)可以通过“^”符号定义否定字符类，匹配所有不在方括号内的字符。(3)还可以用“-”来表示范围a-z，类内部是可以连写的a-zA-Z。 4.预定义类 匹配常见的字符类 字符 等价类 含义 . [^\\r\\n] 除了回车符和换行符之外的所有字符 \\d [0-9] 数字字符 \\D [^0-9] 非数字字符 \\s [\\t\\n\\x0B\\f\\r] 空白符 \\S [^\\t\\n\\x0B\\f\\r] 非空白符 \\w [a-zA-Z_0-9] 单词字符（字母、数字、下划线） \\W [^a-zA-Z_0-9] 非单词字符 5.常用的边界匹配字符（锚字符） 字符 含义 ^ 匹配字符串的开头 $ 匹配字符串的结尾 \\b 单词边界 \\B 非单词边界 \\b 单词边界 (\\b并不匹配单词分隔字符中的任何一个，它只匹配一个位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\\w单词字符)另外：多行匹配时，加上/m后“^”才可以匹配一行的开始，$也是。 量词（重复） 字符 含义 {n,m} 匹配前一项至少n次，但不超过m次 {n,} 匹配前一项n次到多次 {n} 匹配前一项n次 ? 匹配前一项0次或1次，等价于{0,1} + 匹配前一项1次或者多次，等价于{1,} * 匹配前一项0次或多次，等价于{0,} 贪婪模式：匹配重复字符是尽可能多地匹配。默认。而非贪婪模式，只需要在量词后加上一个问号。 分组使用()分组，使量词作用于分组默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。1.使用|可以达到或的效果2.后向引用后向引用用于重复搜索前面某个分组匹配的文本。例如，\\1代表分组1匹配的文本。3.忽略分组不希望捕获某些分组，只需要在分组内加上?:就可以 零宽先行断言1.(?=p)零宽正向先行断言要求接下来的字符都与p匹配，但不能包括匹配p的那些字符。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re studying.时，它会匹配sing和study。2.(?!p)零宽负向先行断言要求接下来的字符不与p匹配 RegExp对象1.五个RegExp对象属性：global、multiline、ignoreCase、lastIndex、source(1)lastIndex：当前表达式匹配内容的最后一个字符的下一个位置(2)source：只读，正则表达式的文本字符串2.两个RegExp对象方法：(1)RegExpObject.test(string)test()方法用于检测一个字符串是否匹配某个模式.如果字符串 string 中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false。(2)RegExpObject.exec(string)exec()方法用于检索字符串中的正则表达式的匹配。如果没有匹配返回null,否则返回一个结果数组。返回的数组具有两个属性：index和input。&emsp;1)数组第一个元素包含的是与正则表达式相匹配的字符串&emsp;2)余下的元素是与子表达式相匹配的字符串&emsp;3)index声明匹配文本的其实字符在字符串的位置&emsp;4)input声明对stringObject的引用 用于模式匹配的String方法1.stringObject.search(regexp)search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。返回第一个匹配结果的index，查找不到返回-1search()方法不支持全局检索，它将忽略修饰符g，并且总是从字符串的开始进行检索。 2.stringObject.match(regexp)match()方法将检索字符串以找到一个或多个正则表达式的匹配。返回一个由匹配结果组成的数组，该数组的内容依赖于 regexp 是否设置了修饰符g。&emsp;(1)没有设置g，非全局检索它只执行一次匹配，如果没有找到任何的匹配文本，返回null否则将返回一个数组，数组第一项存放的是完整的匹配，剩下的存放的是与子表达式相匹配的字符串。返回的数组具有两个属性：index和input（非全局检索与exec返回的一模一样）&emsp;(2)设置了g，全局检索没有找到返回null，找到返回一个数组包含字符串中所有匹配结果。没有index属性和input属性 3.stringObject.split(regexp)split() 方法用于把一个字符串分割成字符串数组。返回一个字符串数组。 4.stringObject.replace(regexp, replacement)replace()方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。返回一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。replacement 可以是字符串，也可以是函数。&emsp;(1)如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。它说明从模式匹配得到的字符串将用于替换。&emsp;(2)replacement是函数的情况，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是index，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。 最后让我们再回到最开始的问题，看着这张可视化工具生成的图，再次回忆一下语法。是不是很容易理解了。 参考资料：《JaveScript权威指南》《正则表达式30分钟入门教程》《微软的正则表达式教程》在线网站：正则表达式可视化工具正则表达式学习正则表达式练习 有没有发现我的MD语法进步了呢……","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"数据结构JavaScript","date":"2017-07-25T07:47:53.000Z","path":"2017/07/25/020/","text":"队列：shift()和unshift()栈：push()和pop()","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"十大排序算法【转】","date":"2017-07-21T07:22:53.000Z","path":"2017/07/21/019/","text":"原文来自Damonare的个人博客另参见JS中的排序 排序算法说明（1）排序的定义：对一序列对象根据某个关键字进行排序； 输入：n个数：a1,a2,a3,…,an输出：n个数的排列:a1’,a2’,a3’,…,an’，使得a1’&lt;=a2’&lt;=a3’&lt;=…&lt;=an’。 （2）对于评述算法优劣术语的说明 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成；外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度: 一个算法执行所耗费的时间。空间复杂度: 运行完一个程序所需内存的大小。 关于时间空间复杂度的更多了解请戳这里，或是看《大话数据结构》，通俗易懂。（3）排序算法图片总结 (图片来源于网络): 排序对比： 图片名词解释：n: 数据规模k:“桶”的个数In-place: 占用常数内存，不占用额外内存Out-place: 占用额外内存 排序分类： 1.冒泡排序（Bubble Sort） 好的，开始总结第一个排序算法，冒泡排序。我想对于它每个学过C语言的都会了解的吧，这可能是很多人接触的第一个排序算法。 (1)算法描述 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 (2)算法描述和实现具体算法描述如下： .比较相邻的元素。如果第一个比第二个大，就交换它们两个； .对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； .针对所有的元素重复以上的步骤，除了最后一个； .重复步骤1~3，直到排序完成。 JavaScript代码实现： function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 改进冒泡排序： 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。 改进后算法如下:function bubbleSort2(arr) &#123; console.time('改进后冒泡排序耗时'); var i = arr.length-1; //初始时,最后位置保持不变 while ( i&gt; 0) &#123; var pos= 0; //每趟开始时,无记录交换 for (var j= 0; j&lt; i; j++) if (arr[j]&gt; arr[j+1]) &#123; pos= j; //记录交换的位置 var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; &#125; i= pos; //为下一趟排序作准备 &#125; console.timeEnd('改进后冒泡排序耗时'); return arr;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bubbleSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。 改进后的算法实现为:function bubbleSort3(arr3) &#123; var low = 0; var high= arr.length-1; //设置变量的初始值 var tmp,j; console.time('2.改进后冒泡排序耗时'); while (low &lt; high) &#123; for (j= low; j&lt; high; ++j) //正向冒泡,找到最大者 if (arr[j]&gt; arr[j+1]) &#123; tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; &#125; --high; //修改high值, 前移一位 for (j=high; j&gt;low; --j) //反向冒泡,找到最小者 if (arr[j]&lt;arr[j-1]) &#123; tmp = arr[j]; arr[j]=arr[j-1];arr[j-1]=tmp; &#125; ++low; //修改low值,后移一位 &#125; console.timeEnd('2.改进后冒泡排序耗时'); return arr3;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bubbleSort3(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 三种方法耗时对比： 由图可以看出改进后的冒泡排序明显的时间复杂度更低，耗时更短了。 冒泡排序动图演示: (3)算法分析 最佳情况：T(n) = O(n) 当输入的数据已经是正序时（都已经是正序了，为毛何必还排序呢….） 最差情况：T(n) = O(n2) 当输入的数据是反序时(卧槽，我直接反序不就完了….) 平均情况：T(n) = O(n2) 2.选择排序（Selection Sort） 表现最稳定的排序算法之一(这个稳定不是指算法层面上的稳定哈，相信聪明的你能明白我说的意思2333)，因为无论什么数据进去都是O(n²)的时间复杂度…..所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。 (1)算法简介 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 (2)算法描述和实现n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： .初始状态：无序区为R[1..n]，有序区为空； .第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； .n-1趟结束，数组有序化了。 Javascript代码实现: function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; console.time('选择排序耗时'); for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数 minIndex = j; //将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; console.timeEnd('选择排序耗时'); return arr;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 选择排序动图演示： (3)算法分析 最佳情况：T(n) = O(n2) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2) 3.插入排序（Insertion Sort） 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了….. (1)算法简介 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 (2)算法描述和实现一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： .从第一个元素开始，该元素可以认为已经被排序； .取出下一个元素，在已经排序的元素序列中从后向前扫描； .如果该元素（已排序）大于新元素，将该元素移到下一位置； .重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； .将新元素插入到该位置后； .重复步骤2~5。 Javascript代码实现: function insertionSort(array) &#123; if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; console.time('插入排序耗时：'); for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i]; var j = i - 1; while (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123; array[j + 1] = array[j]; j--; &#125; array[j + 1] = key; &#125; console.timeEnd('插入排序耗时：'); return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125; 改进插入排序： 查找插入位置时使用二分查找的方式 function binaryInsertionSort(array) &#123; if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; console.time('二分插入排序耗时：'); for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i], left = 0, right = i - 1; while (left &lt;= right) &#123; var middle = parseInt((left + right) / 2); if (key &lt; array[middle]) &#123; right = middle - 1; &#125; else &#123; left = middle + 1; &#125; &#125; for (var j = i - 1; j &gt;= left; j--) &#123; array[j + 1] = array[j]; &#125; array[left] = key; &#125; console.timeEnd('二分插入排序耗时：'); return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 改进前后对比： 插入排序动图演示: (3)算法分析 最佳情况：输入数组按升序排列。T(n) = O(n) 最坏情况：输入数组按降序排列。T(n) = O(n2) 平均情况：T(n) = O(n2) 4.希尔排序（Shell Sort） 1959年Shell发明；第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序 (1)算法简介 希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。 (2)算法描述和实现先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： . 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； .按增量序列个数k，对序列进行k 趟排序； .每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 Javascript代码实现： function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; console.time('希尔排序耗时:'); while(gap &lt; len/5) &#123; //动态定义间隔序列 gap =gap*5+1; &#125; for (gap; gap &gt; 0; gap = Math.floor(gap/5)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123; arr[j+gap] = arr[j]; &#125; arr[j+gap] = temp; &#125; &#125; console.timeEnd('希尔排序耗时:'); return arr;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(shellSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 希尔排序图示： （3）算法分析 最佳情况：T(n) = O(nlog2 n) 最坏情况：T(n) = O(nlog2 n) 平均情况：T(n) =O(nlog n) 5.归并排序（Merge Sort） 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。 (1)算法简介 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 (2)算法描述和实现具体算法描述如下： .把长度为n的输入序列分成两个长度为n/2的子序列； .对这两个子序列分别采用归并排序； .将两个排序好的子序列合并成一个最终的排序序列。 Javscript代码实现: function mergeSort(arr) &#123; //采用自上而下的递归方法 var len = arr.length; if(len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right)&#123; var result = []; console.time('归并排序耗时'); while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); console.timeEnd('归并排序耗时'); return result;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(mergeSort(arr)); 归并排序动图演示: (3)算法分析 最佳情况：T(n) = O(n) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 6.快速排序（Quick Sort） 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。 (1)算法简介 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 (2)算法描述和实现快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： .从数列中挑出一个元素，称为 “基准”（pivot）； .重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； .递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 Javascript代码实现： /*方法说明：快速排序@param array 待排序数组*///方法一function quickSort(array, left, right) &#123; console.time('1.快速排序耗时'); if (Object.prototype.toString.call(array).slice(8, -1) === 'Array' &amp;&amp; typeof left === 'number' &amp;&amp; typeof right === 'number') &#123; if (left &lt; right) &#123; var x = array[right], i = left - 1, temp; for (var j = left; j &lt;= right; j++) &#123; if (array[j] &lt;= x) &#123; i++; temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; quickSort(array, left, i - 1); quickSort(array, i + 1, right); &#125; console.timeEnd('1.快速排序耗时'); return array; &#125; else &#123; return 'array is not an Array or left or right is not a number!'; &#125;&#125;//方法二var quickSort2 = function(arr) &#123; console.time('2.快速排序耗时'); if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125;console.timeEnd('2.快速排序耗时'); return quickSort2(left).concat([pivot], quickSort2(right));&#125;;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(quickSort(arr,0,arr.length-1));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]console.log(quickSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 快速排序动图演示： (3)算法分析 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(nlogn) 7.堆排序（Heap Sort） 堆排序可以说是一种利用堆的概念来排序的选择排序。 (1)算法简介 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 (2)算法描述和实现具体算法描述如下： .将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； .将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； .由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 Javascript代码实现： /*方法说明：堆排序@param array 待排序数组*/function heapSort(array) &#123; console.time('堆排序耗时'); if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') &#123; //建堆 var heapSize = array.length, temp; for (var i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i--) &#123; heapify(array, i, heapSize); &#125; //堆排序 for (var j = heapSize - 1; j &gt;= 1; j--) &#123; temp = array[0]; array[0] = array[j]; array[j] = temp; heapify(array, 0, --heapSize); &#125; console.timeEnd('堆排序耗时'); return array; &#125; else &#123; return 'array is not an Array!'; &#125;&#125;/*方法说明：维护堆的性质@param arr 数组@param x 数组下标@param len 堆大小*/function heapify(arr, x, len) &#123; if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' &amp;&amp; typeof x === 'number') &#123; var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp; if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123; largest = l; &#125; if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123; largest = r; &#125; if (largest != x) &#123; temp = arr[x]; arr[x] = arr[largest]; arr[largest] = temp; heapify(arr, largest, len); &#125; &#125; else &#123; return 'arr is not an Array or x is not a number!'; &#125;&#125;var arr=[91,60,96,13,35,65,46,65,10,30,20,31,77,81,22];console.log(heapSort(arr));//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96] 堆排序动图演示： (3)算法分析 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 8.计数排序（Counting Sort） 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 (1)算法简介 计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。 (2)算法描述和实现具体算法描述如下： . 找出待排序的数组中最大和最小的元素； . 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； . 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； . 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 Javascript代码实现： function countingSort(array) &#123; var len = array.length, B = [], C = [], min = max = array[0]; console.time('计数排序耗时'); for (var i = 0; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1; &#125; for (var j = min; j &lt; max; j++) &#123; C[j + 1] = (C[j + 1] || 0) + (C[j] || 0); &#125; for (var k = len - 1; k &gt;= 0; k--) &#123; B[C[array[k]] - 1] = array[k]; C[array[k]]--; &#125; console.timeEnd('计数排序耗时'); return B;&#125;var arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];console.log(countingSort(arr)); //[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9] JavaScript动图演示：、 (3)算法分析 当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。 最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n+k) 9.桶排序（Bucket Sort） 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 (1)算法简介 桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排 (2)算法描述和实现具体算法描述如下： .设置一个定量的数组当作空桶； .遍历输入数据，并且把数据一个一个放到对应的桶里去； .对每个不是空的桶进行排序； .从不是空的桶里把排好序的数据拼接起来。 Javascript代码实现: /*方法说明：桶排序@param array 数组@param num 桶的数量*/function bucketSort(array, num) &#123; if (array.length &lt;= 1) &#123; return array; &#125; var len = array.length, buckets = [], result = [], min = max = array[0], regex = '/^[1-9]+[0-9]*$/', space, n = 0; num = num || ((num &gt; 1 &amp;&amp; regex.test(num)) ? num : 10); console.time('桶排序耗时'); for (var i = 1; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; &#125; space = (max - min + 1) / num; for (var j = 0; j &lt; len; j++) &#123; var index = Math.floor((array[j] - min) / space); if (buckets[index]) &#123; // 非空桶，插入排序 var k = buckets[index].length - 1; while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; array[j]) &#123; buckets[index][k + 1] = buckets[index][k]; k--; &#125; buckets[index][k + 1] = array[j]; &#125; else &#123; //空桶，初始化 buckets[index] = []; buckets[index].push(array[j]); &#125; &#125; while (n &lt; num) &#123; result = result.concat(buckets[n]); n++; &#125; console.timeEnd('桶排序耗时'); return result;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bucketSort(arr,4));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 桶排序图示（图片来源网络）： 关于桶排序更多 (3)算法分析 桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n2) 10.基数排序（Radix Sort） 基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数； (1)算法简介 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。 (2)算法描述和实现具体算法描述如下： .取得数组中的最大数，并取得位数； .arr为原始数组，从最低位开始取每个位组成radix数组； .对radix进行计数排序（利用计数排序适用于小范围数的特点）； Javascript代码实现： /** * 基数排序适用于： * (1)数据范围较小，建议在小于1000 * (2)每个数值都要大于等于0 * @author xiazdong * @param arr 待排序数组 * @param maxDigit 最大位数 *///LSD Radix Sortfunction radixSort(arr, maxDigit) &#123; var mod = 10; var dev = 1; var counter = []; console.time('基数排序耗时'); for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; for(var j = 0; j &lt; arr.length; j++) &#123; var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]== null) &#123; counter[bucket] = []; &#125; counter[bucket].push(arr[j]); &#125; var pos = 0; for(var j = 0; j &lt; counter.length; j++) &#123; var value = null; if(counter[j]!=null) &#123; while ((value = counter[j].shift()) != null) &#123; arr[pos++] = value; &#125; &#125; &#125; &#125; console.timeEnd('基数排序耗时'); return arr;&#125;var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(radixSort(arr,2)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 基数排序LSD动图演示： (3)算法分析 最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k) 基数排序有两种方法： MSD 从高位开始进行排序 LSD 从低位开始进行排序 基数排序 vs 计数排序 vs 桶排序 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶 计数排序：每个桶只存储单一键值 桶排序：每个桶存储一定范围的数值 参考链接sorts","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"从输入URL到页面加载完成到底发生了什么？","date":"2017-07-19T01:22:09.000Z","path":"2017/07/19/018/","text":"&emsp;&emsp;这应该是我开始学习前端之后看到的次数最多的一道面试题目，也是我最怕的一道题目了。计算机网络和硬件方面我还是个文盲，我对软件一直更感兴趣一点，对网络和硬件就比较心虚，寒暑假回家大爷大妈让我修电脑的时候，我只能无奈地一再强调自己是学软件的。为了更好地 为人民服务 学习前端，我准备从头到尾理清这道题，借此完成计算网络的攻坚克难战，顺便准备技术交流的素材。&emsp;&emsp;在我最开始的意识里，这个过程应该是在浏览器地址栏输入URL之后信息被送到了某处，然后获得回复，内容按照一定格式(前端要做的工作)展示在Web页面上。而事实上在电脑显示器后面在这短短的时间(网速好的话)内有太多看不到的过程发生了。 1.输入URL后浏览器做了什么我们先来理解一下URL是什么，它为我们做了什么 (1)URL Uniform Resource Locator 统一资源定位符URI（Uniform Resource Identifier) 统一资源标识符URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置），URL是URI的子集。URL的一般格式为(带方括号[]的为可选项)：protocol :// hostname[:port] / path / [;parameters][?query]#fragment URL由三部分组成：协议类型，主机名和路径及文件名。通过URL可以指定的主要有以下几种：http、ftp、gopher、telnet、file等。 1、protocol（协议）：指定使用的传输协议 file 资源是本地计算机上的文件。格式file:// ftp 通过 FTP访问资源。格式 FTP:// http 通过 HTTP 访问该资源。格式 HTTP:// https 通过安全的 HTTPS 访问该资源。格式 HTTPS:// mailto 资源为电子邮件地址，通过 SMTP 访问。格式 mailto: 2、hostname（主机名）：是指存放资源的服务器的域名系统 (DNS) 主机名或 IP 地址。有时，在主机名前也可以包含连接到服务器所需的用户名和密码（格式：username:password）。 3、port（端口号）：整数，可选，省略时使用方案的默认端口，各种传输协议都有默认的端口号，如http的默认端口为80。如果输入时省略，则使用默认端口号。有时候出于安全或其他考虑，可以在服务器上对端口进行重定义，即采用非标准端口号，此时，URL中就不能省略端口号这一项。 4、path（路径）：由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。 5、;parameters（参数）：这是用于指定特殊参数的可选项。 6、?query(查询)：可选，用于传递参数，可有多个参数，用“&amp;”符号隔开，每个参数的名和值用“=”符号隔开。 7、fragment，代表了资源内的一个位置。 在 URI 的末尾通过 hash mark（#）作为 fragment 的开头，其中#不属于 fragment 的值。1.#有别于?。?后面的查询字符串会被网络请求带上服务器，而 fragment 不会被发送的服务器；2.fragment 的改变不会触发浏览器刷新页面，但是会生成浏览历史（对IE 6和IE 7不成立）；3.fragment 会被浏览器根据文件媒体类型（MIME type）进行对应的处理；4.Google 的搜索引擎会忽略 # 及其后面的字符串。如果希望Ajax生成的内容被浏览引擎读取，可以使用”#!”5.JS中可以通过window.location.hash来读取或改变＃的值 (2)负责域名解析的DNS服务 Domain Name System 应用层DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务URL和DNS协议为我们标识了资源的地点，让我们知道去哪里请求需要的资源。 2.在传输过程中发生了什么Web采用HTTP协议作为规范，完成从客户端到服务器端的通信。HTTP协议 Hyper Text Transfer Protocol 超文本传输协议 应用层HTTP协议基于TCP/IP协议族进行网络通信。其中包括： (1)负责传输的IP协议 Internet Protocol 网际协议 网络层MAC地址 Media Acess Control Address使用ARP协议进行通信 (2)确保可靠性的TCP协议 Transmission Control Protocol 传输控制协议 传输层为什么说它是确保可靠性的呢，TCP协议为了准确无误的将数据送达目标处采用了三次握手three-way-handshaking策略TCP 协议的三次握手 – 用以确认数据传输正确，会重试到完整地完成为止。 TCP/IP传输流：作为发送端的客户端在应用层（HTTP协议）发出HTTP请求。为了传输方便在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在格格报文上打上标记序号及端口号后转发给网络层。在网络层（IP协议）增加作为通讯目的地的MAC地址后转发给数据链路层。接收端的服务器在数据链路层接收到数据，发送到网络层传输层一直到应用层。这时候接收端的服务器才真正收到了了客户端的HTTP请求。 HTTP请求由三部分组成，分别是：请求行、首部字段、报文主体请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。 请求方法有多种： 请求方法 说明 GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据 HEAD 请求获取由Request-URI所标识的资源的响应消息报头 PUT 请求服务器存储一个资源，并用Request-URI作为其标识 DELETE 请求服务器删除Request-URI所标识的资源 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求 在html页面中输入URL、访问超链接、form提交（当然也可以设置method为POST）等都是GET请求方法，比如本题“从输入URL到页面加载完成到底发生了什么？” GET和POST对比：GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。GET是幂等的POST：一般用于修改服务器上的资源，对所发送的信息没有限制。GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。然而，在以下情况中，请使用 POST 请求：无法使用缓存文件（更新服务器上的文件或数据库）；向服务器发送大量数据（POST 没有数据量限制）；发送包含未知字符的用户输入时，POST比GET更稳定也更可靠。 HTTP响应也是由三个部分组成，分别是：状态行、首部字段、报文主体状态行格式：HTTP-Version Status-Code Reason-Phrase CRLF其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。比如HTTP/1.1 200 OK 响应状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 响应状态代码 状态描述 说明 1xx 指示信息 表示请求已接收，继续处理 2xx 成功 表示请求已被成功接收、理解、接受 3xx 重定向 要完成请求必须进行更进一步的操作 4xx 客户端错误 请求有语法错误或请求无法实现 5xx 服务器端错误 服务器未能实现合法的请求 常见状态代码、状态描述、说明： 常见状态代码 状态描述 说明 200 OK 客户端请求成功 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized 请求未经授权，必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务 404 Not Found 请求资源不存在，eg：输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误 503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 从100到199范围的HTTP状态码是信息报告码。基于各种原因考虑，大多数情况下我们是很少看见这些代码的。首先，如果一个浏览器尝试访问一个网站，而网站返回这些代码时，它们往往都不会显示在屏幕上。它们只是浏览器使引用的内部码。另外，这些代码不常见的另外一个原因是起初HTTP标准不允许使用这一范围的状态码。就其本身而言，它们也一直没有被广泛地使用。 HTTP/1.1首部字段 通用首部字段 首部字段名 说明 Cache-Control 控制缓存的行为 Connection 逐跳首部、连接的管理 Date 创建报文的日期时间 Pragma 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知 请求首部字段 首部字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言（自然语言） Authorization Web认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在服务器 if-Match 比较实体标记（ETag） if-Modified-Since 比较资源的更新时间 if-None-Match 比较实体标记（与if-Match相反） if-Range 资源未更新时发送实体Byte的范围请求 if-Unmodified-Since 比较资源的更新时间（与if-Modified-Since相反） Max-Forwards 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中URI的原始获取方法 TE 传输编码的优先级 User-Agent HTTP客户端程序的信息 响应首部字段 首部字段名 说明 Accept-Ranges 是否接受字节范围请求 Age 推算资源创建经过时间 ETag 资源的匹配信息 Location 令客户端重定向至指定的URI Proxy-Authenticate 代理服务器对客户端的认证信息 Reter-After 对再次发起请求的时机要求 Server HTTP服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 实体首部字段 首部字段名 说明 Allow 资源可支持的HTTP方法 Content-Encoding 实体主体的适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小（单位：字节） Content-Location 替代对应资源的URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期的日期时间 Last-Modified 资源的最后修改日期时间 在这里同学问我Expires是缓存还是Cookie的失效时间。Expires是将资源失效的日期告知客户端。源服务器不希望缓存服务器对资源缓存时会将Expires字段写入与首部字段Date相同的时间值，就像当时看到的百度的示例。但当同时存在Cache-control的max-age会优先处理max-age指令，忽略掉Expires。max-age代表资源保存为缓存的最长时间。 响应的结果也同样利用TCP/IP通信协议向客户端回传。 这里我的同学帮我补充了一点：关于cookie的状态管理HTTP是无状态协议，他不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。Cookie会根据从服务器端发送的响应的报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后的到之前的状态信息。 还有一种服务端的机制——Session。Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Redis之类的来放 Session。区别：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式 3.请求到数据后浏览器做了什么当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：解析 —— HTML，CSS，JS渲染 —— 构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制（1）首先，浏览器渲染引擎从网络层取得请求的资源，一般以8kB大小分块传输。（2）HTML解析器对HTML文档进行解析，生成解析树。解析树是以DOM（文档对象模型 Document Object Model）元素以及属性为节点的树。它是HTML文档的对象表示，同时也是HTML元素面向外部(如Javascript)的接口。树的根部是”Document”对象。整个DOM和HTML文档几乎是一对一的关系。（3）遇到css标签解析CSS生成CSS规则树（4）浏览器通过遍历CSS规则树和DOM节点树创建一个渲染树（Render Tree）（5）页面布局和绘制 注意：渲染结束后，JavaScript下载后JS操作修改DOM、修改样式都会造成渲染树的重新布局和重绘。只要修改DOM或修改了元素的形状或大小，就会触发Reflow，单纯修改元素的颜色只需Repaint一下。 参考资料：《图解http》腾讯IMWeb知乎专栏what-happens-when6 Things You Should Know About Fragment URLs","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"一道JavaScript面试题","date":"2017-07-05T02:50:38.000Z","path":"2017/07/05/017/","text":"用一道JavaScript面试题展开讲去。 第一部分：Object Prototypes (对象原型)定义一个方法，传入一个string类型的参数，然后将string的每个字符间加个空格返回，例如： spacify('hello world') // =&gt; 'h e l l o w o r l d' 改写成一个函数。 function spacify(str) &#123; return str.split('').join(' ');&#125; 把这个方法放入String对象上面，例如： 'hello world'.spacify(); function prototypes(方法原型)，直接在对象的原型（prototypes）上添加方法是否安全，尤其是在Object对象上： String.prototype.spacify = function()&#123; return this.split('').join(' ');&#125;; 解释一下函数声明和函数表达式的区别。 第二部分：参数arguments是否理解参数（arguments）对象，定义一个未定义的log方法 log('hello world') 定义log代理console.log的方法。 function log(msg) &#123; console.log(msg);&#125; 改变我调用log的方式，传入多个参数。传入参数的个数是不定的，不止两个。 log('hello', 'world'); 使用apply。apply和call的区别。传入console的上下文也非常重要。 function log()&#123; console.log.apply(console, arguments);&#125;; 给每一个log消息添加一个”(app)”的前辍，比如： '(app) hello world' arugments是一个类数组，转化为标准数组。使用Array.prototype.slice，像这样： function log()&#123; var args = Array.prototype.slice.call(arguments); args.unshift('(app)'); console.log.apply(console, args);&#125;; 第三部分：上下文对上下文和this的理解。count属性不是只读取当前上下文的。 var User = &#123; count: 1, getCount: function() &#123; return this.count; &#125;&#125;; log输出的会是什么。 console.log(User.getCount());var func = User.getCount;console.log(func()); 正确的答案是1和undefined。func是在winodw的上下文中被执行的，所以会访问不到count属性。func访问到count可以使用Function.prototype.bind，例如： var func = User.getCount.bind(User);console.log(func()); 这个方法对老版本的浏览器不起作用，如何解决这个问题。理解apply和call，使用apply实现bind Function.prototype.bind = Function.prototype.bind || function(context)&#123; var self = this; return function()&#123; return self.apply(context, arguments); &#125;;&#125; 第四部分：弹出窗口（Overlay library）通过做一个‘弹出窗口’的库，通过以下几点来实现：在遮罩中最好使用position中的fixed代替absolute属性，这样即使在滚动的时侯，也能始终让遮罩始盖住整个窗口。解释fixed和absolute定位的区别。 .overlay &#123; position: fixed; left: 0; right: 0; bottom: 0; top: 0; background: rgba(0,0,0,.8);&#125; 如何让里面的内容居中，如果内容有固定的宽、高可以选择CSS和绝对定位，否则就要使用JavaScript. .overlay article &#123; position: absolute; left: 50%; top: 50%; margin: -200px 0 0 -200px; width: 400px; height: 400px;&#125; 当遮罩被点击时要自动关闭，这会很好地考查事件冒泡机制的机会。在overlay上面直接绑定一个点击关闭的方法。 $('.overlay').click(closeOverlay); 这是个方法，点击窗口里面的东西也会关闭overlay——这明显是个BUG。解决方法是检查事件的触发对象和绑定对象是否一致，从而确定事件不是从子元素里面冒上来的： $('.overlay').click(function(e)&#123; if (e.target == e.currentTarget) closeOverlay();&#125;);","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"浏览器兼容性","date":"2017-06-25T11:47:53.000Z","path":"2017/06/25/016/","text":"浏览器兼容性","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"DOM事件","date":"2017-06-07T01:47:53.000Z","path":"2017/06/07/015/","text":"JavaScript与HTML之间的交互式通过事件实现的。事件就是文档或者浏览器窗口中发生的一些特定的交互瞬间。 事件流即事件传播（event propagation），描述的是从页面接收事件的顺序。IE的是事件冒泡流，Netcape是事件捕获流。 1.事件冒泡IE的事件流叫做事件冒泡（event bubbing），即事件最开始由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播至较为不具体的那个节点（文档）。IE9等会一直冒泡到window对象。 2.事件捕获Netcape提出的另一种事件流叫做事件捕获（event capturing）。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。目前现代浏览器（IE9、chrome等）都支持这种这种事件流模型。但因为老版本不支持，很少使用。 DOM事件流“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。IE9等都会在捕获阶段触发事件对象上的事件。结果就是有两个机会在目标对象上面操作事件。IE8之下不支持DOM事件流。 事件处理程序事件处理程序（event handler）或事件监听程序（event listener）是处理或者响应事件的函数。处理事件程序的名字以”on”开头，比如click事件的事件处理程序就是onclick 1.HTML事件处理程序某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定。这个特性的值应该是能够执行的JavaScript代码。&lt;input type=\"button\" value=\"HTML事件处理程序\" id=\"btn1\" onclick=\"showMes()\"&gt; 缺点1.时差问题：使用try-catch块捕捉错误。onclick=”try { showMessage() ;} catch(ex) {}”2.程序的作用域链在不同浏览器中会导致不同结果3.HTML和JS代码耦合紧密 2.DOM0级事件处理程序通过JS指定时间处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。首先要取得一个要操作的对象的引用。每个元素（包括window和document）都有自己的事件处理程序属性，这些属性通常全部小写，例如onclick。将这种属性的值设置为一个函数就可以指定事件处理程序。var btn2 = document.getElementById(\"btn2\");btn2.onclick = function() &#123; alert(\"这是通过DOM0级添加的事件\");&#125;; 优点:比较简单，跨浏览器的优势事件处理程序在元素的作用域中运行，this指向当前元素。会在事件流的冒泡阶段被处理删除事件处理程序：btn.onclick = null; 3.DOM2级事件处理程序DOM2级事件定义了两个方法：用于处理指定和删除事件处理程序的操作addEventListener和removeEventListener。接收3个参数，要处理的事件名称（不包含on）、作为事件处理程序的函数和一个布尔值。如果为true，表示在捕获时执行事件处理函数；如果为false，表示在冒泡阶段调用事件处理程序。大多数情况下用false。 addEventListener()添加的只能用removeEventListener()删除，而且参数都要一致。好处：可以添加多个事件处理程序。先添加先执行。问题：匿名函数无法移除。 var handler = function()&#123; alert(this.id);&#125;;btn.addEventListener(\"click\", handler, false);btn.removeEventListener(\"click\", handler, false); 4.IE事件处理程序attachEvent()添加事件detachEvent()删除事件接收两个参数：事件处理程序的名称（有on）和事件处理程序的函数 没有第三个参数，是因为IE8及更早版本只支持事件冒泡，默认添加到冒泡阶段注意：使用DOM方法时，事件会在所属元素的作用域内运行；使用attachEvent()方法，事件处理程序会在全局作用域运行，this等于window。好处：可以添加多个事件处理程序。后添加先执行。问题：匿名函数无法移除。支持IE事件处理的有IE和Opera var handler = function()&#123; alert(this.id);&#125;;btn.attachEvent (“onclick”, handler);btn.detachEvent (“onclick”, handler); 5.跨浏览器的事件处理程序创建一个对象eventUtil，拥有两个方法。addHandler(要操作的元素，事件名称，事件处理函数)。removeHandler(要操作的元素，事件名称，事件处理函数)。 var eventUtil = &#123; //添加句柄 addHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = handler; &#125; &#125;, //删除句柄 removeHandler: function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.attachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = null; &#125; &#125;&#125; 事件对象事件对象（event object）：在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。1.DOM中的事件对象（1）type属性 被触发的事件的类型（2）target属性 事件的目标（3）stopPropagation()方法 取消事件的进一步捕获或冒泡（4）preventDefault()方法 取消事件的默认行为2.IE中的事件对象event对象作为window对象的一个属性存在。（1）type属性 被触发的事件的类型（2）srcElement属性 事件的目标（3）cancelBubble属性 默认为false，设置成true可阻止事件冒泡（4）returnValue属性 默认值为ture，设置成false可取消时间的默认行为 由于IE不支持事件捕获， 更多属性方法，可查看W3C的事件：W3C的DOM事件参考手册 3.跨浏览器的事件对象var eventUtil = &#123; addHandler: function(element, type, handler) &#123; //忽略 &#125;, removeHandler: function(element, type, handler) &#123; //忽略 &#125;， getEvent: function(event) &#123; return event ? event : window.event; &#125;, getType: function(event) &#123; return event.type; &#125;, getElement: function(event) &#123; return event.target || event.srcElement; &#125;, preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;&#125; 事件类型一. DOM3级事件规定以下类型：UI事件：当用户与页面上的元素交互时触发焦点事件：当元素获得或失去焦点时触发鼠标事件：当用户通过鼠标在页面上执行操作时触发滚轮事件：当使用鼠标滚轮时触发文本事件：当在文档中输入文本时触发键盘事件：在用户通过键盘在页面上执行操作时触发合成事件：当为输入法编辑器输入字符时触发变动事件：当底层DOM结构发生变化时触发 二. UI事件UI事件：当用户与页面上的元素交互时触发1.load事件当页面完全加载后（包括所有图形、JavaScript文件、CSS文件等外部），就会触发window上面的load事件。window.onload = function() &#123; alert(\"loaded!\");&#125; 图像上面也可以触发load事件。在创建新的img元素时，要在指定src属性之前先指定事件。&lt;!--img元素也可以指定load事件，当图像成功下载执行load事件--&gt; &lt;!--如果图像路径有误，或者其他原因导致没有下载完成，则不会执行load事件--&gt; &lt;img src=\"smile.gif\" onload=\"alert('Image loaded.')\" /&gt; 在IE9+的浏览器中，script标签也能触发load事件。 2.unload事件unload事件在文档被完全卸载后触发，只要用户从一个页面切换到另一个页面，就会发生unload事件。利用这个事件最多的情况是清除引用，以避免内存泄露。 3.resize事件当浏览器窗口被调整到一个新的高度或宽度时，就会触发resize事件，这个事件在window上面触发。resize事件有可能被频繁执行，因此不适合在这个事件的处理程序中加入大计算量的代码。 4.scroll事件scroll事件是在window对象上发生的，但它实际表示的是页面中相应元素的变化。与resize事件类似，scroll事件也会在文档被滚动期间重复被触发。 三. 焦点事件焦点元素会在页面元素获得或失去焦点时触发。利用这些事件并于document.hasFocus()方法及document.activeElement属性配合，可以知晓用户在页面上的行踪。 常用焦点事件： 名称 触发方式 是否冒泡 blur 元素失去焦点时触发 否 focus 元素获得焦点时触发 否 focusin 元素获得焦点时触发 是 focusout 元素失去焦点时触发 是 四. 鼠标事件鼠标事件是Web开发中最常用的一类事件。1.列表 名称 触发方式 是否冒泡 click 单击鼠标左键或按下回车键 是 dblclick 双击鼠标左键 是 mousedown 按下任意鼠标按钮 是 mouseup 释放任意鼠标按键 是 mouseenter 鼠标指针从元素外部首次移动到元素范围内 否 mouseleave 鼠标指针从元素范围内移出 否 mouseout 鼠标指针位于一个元素上方，然后移入另一个元素 是 mouseover 鼠标指针从元素外部首次移动到元素范围内 是 mousemove 鼠标指针在元素内部移动 是 2.关联只有在同一个元素上相继触发mousedown和mouseup事件，才会触发click事件。只有触发两次click事件，才会触发一次dblclick事件。IE6 - 8中，双击时会跳过第二次mousedown和click事件.3.坐标位置鼠标事件发生的坐标位置保存在事件对象中。myDIv.addEventListener(\"click\", function(e)&#123; alert(e.clientX + \",\" + e.clientY); //在窗口中的位置 alert(e.pageX + \",\" + e.pageY); //在页面中的位置 alert(e.screenX + \",\" + e.screenY); //在屏幕中的位置&#125;, false); 参考资料：JS高级程序设计W3school HTML DOM参考手册","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"HTML DOM参考手册","date":"2017-05-12T11:11:53.000Z","path":"2017/05/12/014/","text":"在 HTML DOM （文档对象模型）中，每个部分都是节点： 文档本身是文档节点所有 HTML 元素是元素节点所有 HTML 属性是属性节点HTML 元素内的文本是文本节点注释是注释节点 HTML DOM Document 对象 方法 描述 getElementById() 返回对拥有指定 id 的第一个对象的引用 getElementsByName() 返回带有指定名称的NodeList getElementsByTagName() 返回包含带有指定标签名称的所有元素的NodeList getElementsByClassName() 返回包含带有指定类名的所有元素的NodeList createAttribute() 创建拥有指定名称的属性节点，并返回新的 Attr 对象 createElement() 创建元素节点 createTextNode() 创建文本节点 HTML DOM Element 对象在 HTML DOM 中，Element 对象表示 HTML 元素。Element 对象可以拥有类型为元素节点、文本节点、注释节点的子节点。NodeList 对象表示节点列表，比如 HTML 元素的子节点集合。 方法 描述 appendChild() 向元素添加新的子节点，作为最后一个子节点 removeChild() 从元素中移除子节点 getAttribute() 返回元素节点的指定属性值 setAttribute() 把指定属性设置或修改为指定的值 removeAttribute() 从元素中移除指定属性 属性是节点（HTML 元素）的值，可以获取或设置。 属性 描述 innerHTML 设置或返回元素的内容 attributes 返回元素属性的 NamedNodeMap childNodes 返回元素子节点的 NodeList parentNode 返回元素的父节点 nodeName 返回元素的名称 nodeType 返回元素的节点类型 nodeValue 设置或返回元素值 Element.outerHTML 获取描述包括其后代的元素的序列化HTML片段Node.innerText 是一个表示一个节点及其后代的“渲染”文本内容的属性。HTMLElement.outerText是一个非标准的属性。作为一个得到器，它返回相同的值作为Node.innerText. 作为一个设置器，它将删除当前节点并将其替换为给定的文本. 1.nodeName 属性 nodeName 属性规定节点的名称，只读如果节点是 元素节点，则 nodeName 属性返回 标签名入股节点是 属性节点，则 nodeName 属性返回 属性的名称对于其他节点类型，nodeName 属性返回不同节点类型的不同名称。 2.nodeValue 属性 nodeValue 属性规定节点的值。元素节点的 nodeValue 是 undefined 或 null文本节点的 nodeValue 是 文本本身属性节点的 nodeValue 是 属性值 3.nodeType 属性 nodeType 属性返回以数字值返回指定节点的节点类型，只读。如果节点是 元素节点，则 nodeType 属性将返回 1如果节点是 属性节点，则 nodeType 属性将返回 2 HTML DOM Attribute 对象在 HTML DOM 中，Attr 对象表示 HTML 属性。HTML 属性始终属于 HTML 元素。NamedNodeMap 对象表示元素属性节点的无序集合。","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"DOM","date":"2017-05-10T05:11:53.000Z","path":"2017/05/10/013/","text":"1、什么是DOM? DOM，文档对象模型（Document Object Model）。DOM是 W3C（万维网联盟）的标准，DOM定义了访问HTML和XML文档的标准。在W3C的标准中，DOM是独于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。 W3C DOM由以下三部分组成： 核心DOM 针对任何结构化文档的标准模型XML DOM 针对XML文档的标准模型HTML DOM 针对HTML文档的标准模型 2、DOM0、DOM1、DOM2、DOM3的区别2.1、DOM0与DHTML DHTML是Dynamic HTML（动态HTML）的简称。DHTML并不是一项新技术，而是将HTML、CSS、JavaScript技术组合的一种描述。即： 利用HTML把网页标记为各种元素利用CSS设置元素样式及其显示位置利用JavaScript操控页面元素和样式 我们在阅读DOM标准的时候，经常会看到DOM0级这样的字眼，实际上DOM0级这个标准是不存在的。所谓DOM0级只是DOM历史坐标系中的一个参照点而已，具体地说DOM0级就是指IE4.0和Netscape navigator4.0最初支持的那个DHTML。 2.2、DOM1的出现 W3C于1998年10月完成了第一级DOM，即：DOM1。W3C将DOM定义为一个与平台和编程语言无关的接口，通过这个接口程序和脚本可以动态的访问和修改文档的内容、结构和样式。DOM1级主要定义了HTML和XML文档的底层结构。在DOM1中，DOM由两个模块组成：DOM Core（DOM核心）和DOM HTML。其中，DOM Core规定了基于XML的文档结构标准，通过这个标准简化了对文档中任意部分的访问和操作。DOM HTML则在DOM核心的基础上加以扩展，添加了针对HTML的对象和方法，比如：JavaScript中的Document对象。 2.3、DOM2 在DOM1的基础上DOM2引入了更多的交互能力，也支持了更高级的XML特性。DOM2将DOM分为更多具有联系的模块。DOM2级在原来DOM的基础上又扩充了鼠标、用户界面事件、范围、遍历等细分模块，而且通过对象接口增加了对CSS的支持。DOM1级中的DOM核心模块也经过扩展开始支持XML命名空间。在DOM2中引入了下列模块，在模块包含了众多新类型和新接口： DOM视图（DOM Views）：定义了跟踪不同文档视图的接口DOM事件（DOM Events）：定义了事件和事件处理的接口DOM样式（DOM Style）：定义了基于CSS为元素应用样式的接口DOM遍历和范围（DOM Traversal and Range）：定义了遍历和操作文档树的接口 完整的DOM2标准(图片来自百度百科): 2.4、DOM3 DOM3级：进一步扩展了DOM，引入了以统一方式加载和保存文档的方法，它在DOM Load And Save这个模块中定义；同时新增了验证文档的方法，是在DOM Validation这个模块中定义的。 DOM3进一步扩展了DOM，在DOM3中引入了以下模块： DOM加载和保存模块（DOM Load and Save）：引入了以统一方式加载和保存文档的方法DOM验证模块（DOM Validation）：定义了验证文档的方法DOM核心的扩展（DOM Style）：支持XML 1.0规范，涉及XML Infoset、XPath和XML Base 3、认识DOMDOM可以将任何HTML描绘成一个由多层节点构成的结构。节点分为12种不同类型，每种类型分别表示文档中不同的信息及标记。每个节点都拥有各自的特点、数据和方法，也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。 先看一张w3school上面的一张图: HTML文档可以说由节点构成的集合，DOM节点有: 1.元素节点：上图中HTML、body、p等都是元素节点，即标签。2.文本节点:向用户展示的内容，如li标签中的JavaScript、DOM、CSS等文本。3.属性节点:元素属性，如a标签的链接属性href=”http://www.baidu.com&quot;。 4、DOM节点类型DOM1级定义了一个Node接口，这个Node接口在JavaScript中是作为Node类型来实现的。除了IE以外，其他所有浏览器都可以访问这个类型。每个节点都有一个nodeType属性，用于表明节点的类型。节点类型通过定义数值常量和字符常量两种方式来表示，IE只支持数值常量。节点类型一共有12种，这里介绍常用的7种类型。如下图： (1)Element(元素节点)：是组成文档树的重要部分，它表示了HTML、xml文档中的元素。通常元素因为有子元素、文本节点或者两者的结合，元素节点是唯一能够拥有属性的节点类型。 (2)Attr(属性节点)：代表了元素中的属性，因为属性实际上是附属于元素的，因此属性节点不能被看做是元素的子节点。因而在DOM中属性没有被认为是文档树的一部分。换句话说，属性节点其实被看做是包含它的元素节点的一部分，它并不作为单独的一个节点在文档树中出现。 (3)Text(文本节点)：是只包含文本内容的节点，在xml中称为字符数据，它可以由更多的信息组成，也可以只包含空白。在文档树中元素的文本内容和属性的文本内容都是由文本节点来表示的。 (4)Comment(注释节点)：表示注释的内容 (5)Document(文档节点) ：是文档树的根节点，它是文档中其他所有节点的父节点。要注意的是，文档节点并不是HTML、xml文档的根元素，因为在xml文档中，处理指令、注释等内容可以出现在根元素之外，所以我们在构造DOM树的时候，根元素并不适合作为根节点，因此就有了文档节点，而根元素是作为文档节点的子节点出现的。 (6)DocumentType(文档类型节点)：每一个Document都有一个DocumentType属性，它的值或者是null，或者是DocumentType对象。比如声明文档类型时!doctype HTML就是文档类型节点。 (7)DocumentFragment(文档片段节点)：是轻量级的或最小的Document对象，它表示文档的一部分或者是一段，不属于文档树。不过它有一种特殊的行为，该行为使得它非常有用。比如：当请求把一个DocumentFragment节点插入到文档的时候，插入的不是DocumentFragment自身，而是它的所有的子孙节点。这使得DocumentFragment成了有用的占位符，暂时存放那些一次插入文档的节点，同时它还有利于实现文档的剪切、复制和粘贴等操作。 5、DOM的nodeType、nodeName、nodeValue根据实验，得出以下汇总表格: 6、domReady6.1、什么是domReady？ 节点是以树的形式组织的，当页面上所有的HTML都转换为节点以后，就叫做DOM树构建完毕，简称为domReady。 6.2、那么浏览器是如何将HTML标签解析变成DOM节点的呢？ 实际上浏览器是通过渲染引擎来实现的，默认情况下渲染引擎可以显示HTML、xml文档及图片，渲染引擎的主要用途，即是将css格式化的HTML和图片在浏览器上进行显示。 6.3、浏览器渲染引擎的基本渲染流程 上图就是webkit内核的HTML渲染的基本过程，但这并不包含解析过程中浏览器加载外部资源，比如图片、脚本、iframe等的一些过程。上面的4步仅仅是HTML结构的渲染过程。而外部资源的加载在HTML结构的渲染过程中是贯彻始终的，即便绘制DOM节点已经完成，而外部资源仍然可能正在加载或者尚未加载。 6.4、domReady的实现策略 浏览器是从上到下，从左向右渲染HTML元素的，把javascript代码写在了body元素最后的位置会在domReady之后去执行的。但在编写大型项目的时候，js文件往往非常多，而且之间会相互调用，大多数都是外部引用的。要实现domReady可以使用以下方法： 1.原来比较常用的是window的onload事件，而该事件的实际效果是：当页面解析/DOM树建立完成，并完成了诸如图片、脚本、样式表甚至是iframe中所有资源的下载后才触发的。这对于很多实际的应用而言有点太“迟”了，比较影响用户体验。 2.jquery中的$(document).ready(function(){})方法。 3.为了解决window.onload的短板，w3c新增了一个DOMContentLoaded事件。在页面的DOM树创建完成后（也就是HTML解析第一步完成）即触发，而无需等待其他资源的加载。 IE8（包括）之前版本由于不支持符合W3C规范的DOMContentLoaded事件，所以需要用hack实现兼容。即domReady实现策略： 1.支持DOMContentLoaded事件的，就使用DOMContentLoaded事件。当初始HTML文档被完全加载和解析时，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架完成加载。2.不支持的使用著名Hack兼容。兼容原理大概就是通过IE中的document.documentElement.doScroll(‘left’)来判断DOM树是否创建完毕。 根据以上策略实现原生JavaScript实现domReady。 MSDN 关于 JScript 的一个方法有段不起眼的话，当页面 DOM 未加载完成时，调用 doScroll 方法时，会产生异常。那么我们反过来用，如果不异常，那么就是页面DOM加载完毕了！ 各个主流框架domReady的实现：点击查看 6.5、domReady与window.onload onload事件是要在所有请求都完成之后才执行，而domReady在加载完dom树之后就能执行，所以domReady比onload执行时间更早。 参考资料：深入浅出DOM基础W3C DOM教程","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"markdown变成HTML","date":"2017-04-26T03:20:43.000Z","path":"2017/04/26/012/","text":"将markdown变成HTML ，使用开源库marked HTML页面中使用 &lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"/&gt; &lt;title&gt;Marked in the browser&lt;/title&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.6/marked.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script&gt; document.getElementById('content').innerHTML = marked('# Marked in browser\\n\\nRendered by **marked**.'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ​","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"到底什么是标准和怪异","date":"2017-04-07T02:27:53.000Z","path":"2017/04/07/011/","text":"在标准模式下，一个块的总宽度=width+margin(左右)+padding(左右)+border(左右)在怪异模式下，一个块的总宽度=width+margin（左右）（既width已经包含了padding和border值） .con_box&#123; box-sizing: content-box; width: 100px; height: 100px; padding: 10px; margin: 50px; border: 10px solid green; background: red;&#125; 在线演示截图：.ie_box&#123; box-sizing: border-box; width: 100px; height: 100px; border: 10px solid green; padding: 10px; margin: 50px; background: red;&#125; 在线演示截图： Doctype浏览器的模式可以分为两类：标准模式和混杂模式。 DOCTYPE，或者称为 Document Type Declaration（文档类型声明，缩写DTD）。通常情况下，DOCTYPE 位于一个 HTML文档的最前面的位置，位于根元素 HTML 的起始标签之前。这样一来，在浏览器解析 HTML 文档正文之前就可以确定当前文档的类型，以决定其需要采用的渲染模式（不同的渲染模式会影响到浏览器对于 CSS 代码甚至 JavaScript 脚本的解析）。 DOCTYPE不存在或形式不正确会导致HTML和XHTML文档以混杂模式呈现。 html5的DOCTYPE声明和严格型HTML声明以及严格型XHTML声明则会使浏览器进入标准模式。 html5既然没有DTD，也就没有严格模式与宽松模式的区别，html5有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。 混杂模式是不可取的，因为其没有兼容性可言。标准模式则是对统一标准实现最好的模式，它要求标签必须闭合（唯一不需要闭合的就是DOCTYPE标签），不能使用已经废弃的标签等。 用JS判断浏览器当前的模式：document.write(document.compatMode == “CSS1Compat” ? “当前处于标准模式” : “当前处于混杂模式”);","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"JavaScript 错误 - Throw、Try 和 Catch","date":"2017-03-31T12:56:03.000Z","path":"2017/03/31/010/","text":"当 JavaScript 引擎执行 JavaScript 代码时，会发生各种错误。可能是语法错误，通常是程序员造成的编码错误或错别字。可能是拼写错误或语言中缺少的功能（可能由于浏览器差异）。可能是由于来自服务器或用户的错误输出而导致的错误。当然，也可能是由于许多其他不可预知的因素。 JavaScript 测试和捕捉try 语句允许我们定义在执行时进行错误测试的代码块。catch 语句允许我们定义当 try 代码块发生错误时，所执行的代码块。JavaScript 语句 try 和 catch 是成对出现的。语法try&#123;//在这里运行代码&#125;catch(err)&#123;//在这里处理错误&#125; Throw 语句throw 语句允许我们创建自定义错误。正确的技术术语是：创建或抛出异常（exception）。如果把 throw 与 try 和 catch 一起使用，那么您能够控制程序流，并生成自定义的错误消息。语法throw exception 异常可以是 JavaScript 字符串、数字、逻辑值或对象。","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"使用node.js和mongoDB建站","date":"2016-10-26T00:44:02.000Z","path":"2016/10/26/009/","text":"这是模仿豆瓣电影做的一个电影网站的demo，实现一个从前端到后端的项目，使用了nodejs、express、mongodb。前端页面采用了jade 模板引擎。在线仓库地址： git将本地项目上传到github(git status)，首先在github上创建一个Git仓库 git init git add . git commit -m &quot;first commit&quot; git remote add origin https://github.com/wongyirong/iMooc.git git push -u origin master 另外:由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库有了内容之后，下次使用git push origin master还有一个问题，当时我在github上创建仓库的时候勾选了Initialize this repository with a README，在git push的时候报错，我当时为了解决问题，强制推送git push -f origin master，总结的时候又查了一下发现可以先将远程pull下来再push git pull -r origin master MongoDBmongoDB手动启动服务：mongod –dbpath=D:\\Develop\\MongoDB\\Server\\3.4\\data\\db注册为windows服务：mongod.exe –logpath “D:\\Develop\\MongoDB\\Server\\3.4\\data\\log\\mongodb.log” –logappend –dbpath “D:\\Develop\\MongoDB\\Server\\3.4\\data\\db” –serviceName “MongoDB” –install安装未成功，解决办法：找到cmd.exe，右键以管理员身份运行，然后再执行上述注册服务的命令。 nodenpm install -g nn latest","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"瀑布流布局","date":"2016-09-29T00:50:38.000Z","path":"2016/09/29/008/","text":"css3多栏布局column1、column的浏览器兼容问题，不同内核要写其前缀-webkit Google浏览器内核-ms IE-o 欧朋opera-moz 火狐FireFox2、column-width 和column-count没有必要同时出现3、column-rule设置列与列之间的边框4、column-gap 设置列间距，不一定定义多少，实际就显示多少。其计算规则：用当前浏览器宽口宽除以定义的列宽，剩下的距离平均分配 jQuery实现瀑布流图片定位1、jQuery是继prototype之后又一个优秀的Javascript框架 2、$(window).width() 浏览器视窗的宽度outerWidth() = padding+border+width;width() = width 3、$.inArray(所找元素,数组) 该方法用于获取元素的索引 4.jQuery遍历的函数each $boxs.each(function(index,value){});index 索引值，value对应的值5.eq(n),从结果集中选取第n的元素 6.$.inArray(value,arr)工具函数，用来判断某个值在数组中的索引 7.each遍历的value是DOM对象。将value DOM对象转换为jQuery对象才能使用其方法 ：$(value)jQuery的$.inArray()方法直接可以得到一个数在数组中的索引$(dom) 将Dom对象转换成jQuery对象 JavaScript实现瀑布流布局中图片排序【原理】第二行的第一个box排在第一行高度最矮的那个下面，第二个排在次矮的那个下面，以此类推。需要一个数组，存放每行每个box的offsetHeight的数组 【要点】1.求数组中最小值Math.min()只能求一组数据的最小值，通过传参，而不是数组。借助apply()方法，apply用来改变函数中this的指向，这里用来改变Math对象中的this指向（apply方法不仅可以更改this的指向，还有一点后面的参数是以数组的形式传进来的，这也它是跟call的一个最大区别，隐式的拉平数组）Math.min.apply(null,hArr); 2.求最小值在数组中的索引封装函数getIndex 3.图片定位(两种方法)position:absolute; 4.存放offsetHeight的数组值hArr要不断更改在每次定位之后，最小高度的box加上定位在其下的box的offsetHeight ；即：hArr[index]+=oBox[i].offsetHeight;","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"爱你就像爱生命","date":"2016-08-16T11:48:49.000Z","path":"2016/08/16/007/","text":"你能建立良好的项目和解决问题，这才是最重要的，而你如何解决它们（所使用的工具）已经并将永远改变。If you can build good projects and solve problems then that’s all that matters, how you solve them (the tools) has and will always change. 珍惜生命 远离IE6","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wongyirong.github.io/tags/学习笔记/"}]},{"title":"岁月轻狂","date":"2016-07-16T07:49:25.000Z","path":"2016/07/16/006/","text":"&emsp;&emsp;昨天整理了豆列，全是自己想买的东西。今天因为凯尔经的秘密打开豆瓣电影，发现大学四年真的看了好多动画电影，那时候雪姐和大静还有伢伢只要有好的片子就不会放过，最神奇的是雪姐总能找到好多久远的但是好看的片子，尤其是认识李晓龙之后。&emsp;&emsp;我还能清晰的记起从青科吃完饭走回去时风的温度、天空的颜色、青科电台放的那首《岁月轻狂》。看向我们宿舍那一块，建筑高高低低，礼堂的屋顶尖尖的，宿舍晾晒的衣服迎风飘扬着。青科操场那一片天空格外的开阔，颜色总是那么多彩，望出去能看到西院操场上的人和远处海边的高楼。在那条路上有一株合欢树，我和伢伢专门去看过它的花。快到东院后门那里有一整墙如瀑的爬山虎，四年来一年比一年生机勃勃。而那面高高的围墙，好像从来没看到过头。从夏天开始一直到初秋，后门有一块地会有花门一样的玫瑰，间或几只钻出铁网对路人say hello。进了后门通往二综路两侧是山樱花和榆叶李，开花的时候满树满树的欣喜，不开花的时候总是映衬得天空特别蓝。树与树之间的空隙里可以看到东院操场，青岛真的是气候宜人，而那里又是风景绝佳，离开时最舍不得的就是那里，四年来在哪里发生过太多故事，欢乐悲伤平静愤怒，见证了我的一切，又陪伴了我的四年，我总想回去看看，什么都不做，就想再走几圈看看远山看看日落。&emsp;&emsp;回忆着竟然想起，大一的冬天，想给强哥织条围巾，寒夜里站在大门口跟卖毛线的大姐学，零下好几度的天气手都冻僵了。可是到最后也没有织好看，后来暑假在家想重新织条，却怎么都想不起怎么起头了。 2016-08-15 18:57:36","tags":[{"name":"随笔","slug":"随笔","permalink":"https://wongyirong.github.io/tags/随笔/"}]}]